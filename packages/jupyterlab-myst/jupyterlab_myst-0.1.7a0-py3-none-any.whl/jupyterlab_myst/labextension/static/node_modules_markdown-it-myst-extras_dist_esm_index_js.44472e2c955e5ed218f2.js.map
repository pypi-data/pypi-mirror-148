{"version":3,"sources":["webpack://jupyterlab-myst/./node_modules/markdown-it-myst-extras/dist/esm/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM,KAAK,MAAM;AACjD,0BAA0B,UAAU,IAAI,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC","file":"node_modules_markdown-it-myst-extras_dist_esm_index_js.44472e2c955e5ed218f2.js","sourcesContent":["/** Parse MyST targets (``(name)=``), blockquotes (``% comment``) and block breaks (``+++``).\n *\n * Adapted from: mdit_py_plugins/myst_blocks/index.py\n */\nexport function mystBlockPlugin(md) {\n    md.block.ruler.before(\"blockquote\", \"myst_line_comment\", parse_line_comment, {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n    });\n    md.block.ruler.before(\"hr\", \"myst_block_break\", parse_block_break, {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n    });\n    md.block.ruler.before(\"hr\", \"myst_target\", parse_target, {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n    });\n    md.renderer.rules.myst_line_comment = render_myst_line_comment;\n    md.renderer.rules.myst_target = render_myst_target;\n}\nfunction parse_line_comment(state, startLine, endLine, silent) {\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    let maximum = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n    }\n    if (state.src[pos] !== \"%\") {\n        return false;\n    }\n    if (silent) {\n        return true;\n    }\n    const token = state.push(\"myst_line_comment\", \"\", 0);\n    token.attrSet(\"class\", \"myst-line-comment\");\n    token.content = state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\"); // rstrip\n    token.markup = \"%\";\n    // search end of block while appending lines to `token.content`\n    let nextLine;\n    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        maximum = state.eMarks[nextLine];\n        if (state.src[pos] !== \"%\") {\n            break;\n        }\n        token.content += \"\\n\" + state.src.slice(pos + 1, maximum).replace(/\\s+$/gm, \"\"); // rstrip\n    }\n    state.line = nextLine;\n    token.map = [startLine, nextLine];\n    return true;\n}\nfunction parse_block_break(state, startLine, endLine, silent) {\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    const maximum = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n    }\n    const marker = state.src.charCodeAt(pos);\n    pos += 1;\n    // Check block marker /* + */\n    if (marker !== 0x2b) {\n        return false;\n    }\n    // markers can be mixed with spaces, but there should be at least 3 of them\n    let cnt = 1;\n    while (pos < maximum) {\n        const ch = state.src.charCodeAt(pos);\n        if (ch !== marker && !state.md.utils.isSpace(ch)) {\n            break;\n        }\n        if (ch === marker) {\n            cnt += 1;\n        }\n        pos += 1;\n    }\n    if (cnt < 3) {\n        return false;\n    }\n    if (silent) {\n        return true;\n    }\n    state.line = startLine + 1;\n    const token = state.push(\"myst_block_break\", \"hr\", 0);\n    token.attrSet(\"class\", \"myst-block\");\n    token.content = state.src.slice(pos, maximum).trim();\n    token.map = [startLine, state.line];\n    token.markup = state.md.utils.fromCodePoint(marker).repeat(cnt);\n    return true;\n}\nconst TARGET_PATTERN = /^\\((?<label>[a-zA-Z0-9|@<>*./_\\-+:]{1,100})\\)=\\s*$/;\nfunction parse_target(state, startLine, endLine, silent) {\n    const pos = state.bMarks[startLine] + state.tShift[startLine];\n    const maximum = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n    }\n    const match = TARGET_PATTERN.exec(state.src.slice(pos, maximum));\n    if (!match) {\n        return false;\n    }\n    if (silent) {\n        return true;\n    }\n    state.line = startLine + 1;\n    const token = state.push(\"myst_target\", \"\", 0);\n    token.attrSet(\"class\", \"myst-target\");\n    token.content = match && match.groups ? match.groups[\"label\"] : \"\";\n    token.map = [startLine, state.line];\n    return true;\n}\nfunction escapeHtml(unsafe) {\n    return unsafe\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/'/g, \"&#039;\");\n}\nfunction render_myst_line_comment(tokens, idx) {\n    const token = tokens[idx];\n    const content = token.content;\n    return `<!-- ${escapeHtml(content).trim()} -->`;\n}\nfunction render_myst_target(tokens, idx) {\n    const token = tokens[idx];\n    const className = \"myst-target\";\n    const label = token.content;\n    const target = `<a href=\"#${label}\">(${label})=</a>`;\n    return `<div class=\"${className}\">${target}</div>`;\n}\n/** Colon fence\n * This plugin directly mimics regular fences, but with `:` colons.\n *\n * Example:\n\n        :::name\n        contained text\n        :::\n *\n*/\nexport function colonFencePlugin(md) {\n    md.block.ruler.before(\"fence\", \"colon_fence\", colon_fence_rule, {\n        alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\", \"footnote_def\"]\n    });\n}\nfunction colon_fence_rule(state, startLine, endLine, silent) {\n    let haveEndMarker = false;\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n    }\n    if (pos + 3 > max) {\n        return false;\n    }\n    const marker = state.src.charCodeAt(pos);\n    if (marker !== 0x3a /* : */) {\n        return false;\n    }\n    // scan marker length\n    let mem = pos;\n    pos = state.skipChars(pos, marker);\n    let len = pos - mem;\n    if (len < 3) {\n        return false;\n    }\n    const markup = state.src.slice(mem, pos);\n    const params = state.src.slice(pos, max);\n    // Since start is found, we can report success here in validation mode\n    if (silent) {\n        return true;\n    }\n    // search end of block\n    let nextLine = startLine;\n    for (;;) {\n        nextLine++;\n        if (nextLine >= endLine) {\n            // unclosed block should be autoclosed by end of document.\n            // also block seems to be autoclosed by end of parent\n            break;\n        }\n        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n        max = state.eMarks[nextLine];\n        if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n            // non-empty line with negative indent should stop the list:\n            // - ```\n            //  test\n            break;\n        }\n        if (state.src.charCodeAt(pos) !== marker) {\n            continue;\n        }\n        if (state.sCount[nextLine] - state.blkIndent >= 4) {\n            // closing fence should be indented less than 4 spaces\n            continue;\n        }\n        pos = state.skipChars(pos, marker);\n        // closing code fence must be at least as long as the opening one\n        if (pos - mem < len) {\n            continue;\n        }\n        // make sure tail has spaces only\n        pos = state.skipSpaces(pos);\n        if (pos < max) {\n            continue;\n        }\n        haveEndMarker = true;\n        // found!\n        break;\n    }\n    // If a fence has heading spaces, they should be removed from its inner block\n    len = state.sCount[startLine];\n    state.line = nextLine + (haveEndMarker ? 1 : 0);\n    const token = state.push(\"fence\", \"code\", 0);\n    token.info = params;\n    token.content = state.getLines(startLine + 1, nextLine, len, true);\n    token.markup = markup;\n    token.map = [startLine, state.line];\n    return true;\n}\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}