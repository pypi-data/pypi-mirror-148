"use strict";
(self["webpackChunkqslwidgets"] = self["webpackChunkqslwidgets"] || []).push([["vendors-node_modules_react-image-labeler_build_index_esm_js"],{

/***/ "./node_modules/react-image-labeler/build/index.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-image-labeler/build/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BatchImageLabeler": () => (/* binding */ BatchImageLabeler),
/* harmony export */   "Demonstrator": () => (/* binding */ Demonstrator),
/* harmony export */   "ImageLabeler": () => (/* binding */ ImageLabeler),
/* harmony export */   "Labeler": () => (/* binding */ Labeler),
/* harmony export */   "VideoLabeler": () => (/* binding */ VideoLabeler)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/material */ "webpack/sharing/consume/default/@mui/material/@mui/material");
/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _mui_icons_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mui/icons-material */ "webpack/sharing/consume/default/@mui/icons-material/@mui/icons-material");
/* harmony import */ var _mui_icons_material__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__);




/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

var RangeSlider = function (_a) {
    var name = _a.name, value = _a.value, onChange = _a.onChange, min = _a.min, max = _a.max, width = _a.width, disabled = _a.disabled, other = __rest(_a, ["name", "value", "onChange", "min", "max", "width", "disabled"]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Stack, { direction: "row", alignItems: "center", spacing: 2, style: width ? { width: width } : {} },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Typography, { fontSize: "small" }, name),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Slider, __assign({}, other, { size: "small", value: value, style: width ? { width: width } : {}, min: min, classes: { thumb: "slider-thumb" }, max: max, disabled: disabled, onChange: function (event, value) { return onChange(value); } }))));
};

var GlobalLabelerContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext({
    setFocus: undefined,
    setToast: undefined,
    container: undefined,
});

var ClickTarget = function () {
    var context = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: {
            width: "100%",
            height: "100%",
            position: "absolute",
            top: 0,
        }, onClick: context.setFocus }));
};

var hsvChannels = 3;
var maxSegmentationIters = 1000000;
var nodeStatusToValue = {
    unknown: 0,
    visited: 127,
    matched: 255,
};
var valueToNodeStatus = {
    0: "unknown",
    127: "visited",
    255: "matched",
};
var directions = [
    { dx: 0, dy: -1 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 1, dy: 0 }, //  East
];
// Taken from https://stackoverflow.com/a/53187807
function findLastIndex(array, predicate) {
    var l = array.length;
    while (l--) {
        if (predicate(array[l], l, array))
            return l;
    }
    return -1;
}
var add = function (p, d) {
    return { x: p.x + d.dx, y: p.y + d.dy };
};
var fill = function (targets, operations, limit) {
    var queue = targets.filter(function (p) { return operations.isInBounds(p); });
    // If we're out of bounds or if this
    // location already matches, return.
    if (queue.length == 0)
        return;
    var targetValues = queue
        .map(operations.getImageValue)
        .filter(function (value) { return !!value; });
    queue.forEach(function (t) { return operations.setMatchValue(t, "matched"); });
    if (targetValues.length === 0)
        return;
    var count = 0;
    var _loop_1 = function () {
        var node = queue.shift();
        var candidates = directions
            .map(function (d) { return add(node, d); })
            .filter(operations.isInBounds)
            .filter(function (c) { return operations.getMatchValue(c) == "unknown"; });
        var matches = candidates.filter(function (c) {
            var comparisonValue = operations.getImageValue(c);
            return (comparisonValue !== undefined &&
                targetValues.some(function (targetValue) {
                    return operations.equals(comparisonValue, targetValue);
                }));
        });
        candidates.forEach(function (c) { return operations.setMatchValue(c, "visited"); });
        matches.forEach(function (m) { return operations.setMatchValue(m, "matched"); });
        queue.push.apply(queue, __spreadArray([], __read(matches), false));
        count += 1;
        if (limit !== undefined && count > limit) {
            return { value: void 0 };
        }
    };
    while (queue.length > 0) {
        var state_1 = _loop_1();
        if (typeof state_1 === "object")
            return state_1.value;
    }
};
var rgb2hsv = function () {
    var rgb = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        rgb[_i] = arguments[_i];
    }
    var _a = __read(rgb, 3), r = _a[0], g = _a[1], b = _a[2];
    var max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min, s = max === 0 ? 0 : d / max, v = max / 255, scale = 6 * d;
    var h;
    switch (max) {
        case min:
            h = 0;
            break;
        case r:
            h = (g - b + d * (g < b ? 6 : 0)) / scale;
            break;
        case g:
            h = (b - r + d * 2) / scale;
            break;
        case b:
            h = (r - g + d * 4) / scale;
            break;
        default:
            throw "Failed to select appropriate value for h.";
    }
    return [h, s, v].map(function (v) { return Math.min(Math.round(v * 255), 255); });
};
var getNaturalDimensions = function (media) {
    return {
        width: media.nodeName === "VIDEO"
            ? media.videoWidth
            : media.naturalWidth,
        height: media.nodeName === "VIDEO"
            ? media.videoHeight
            : media.naturalHeight,
    };
};
var img2hsv = function (img, canvas, max_size) {
    var context = canvas.getContext("2d");
    var natural = getNaturalDimensions(img);
    if (!context) {
        throw Error("Failed to get a drawing context.");
    }
    var scale = max_size / Math.max(natural.width, natural.height);
    canvas.width = Math.round(scale * natural.width);
    canvas.height = Math.round(scale * natural.height);
    context.drawImage(img, 0, 0, natural.width, natural.height, 0, 0, canvas.width, canvas.height);
    try {
        var data_1 = Array.from(context.getImageData(0, 0, canvas.width, canvas.height).data);
        return {
            hsv: new Uint8ClampedArray(Array.from(Array(canvas.width * canvas.height).keys())
                .map(function (i) { return rgb2hsv.apply(void 0, __spreadArray([], __read(data_1.slice(i * 4, i * 4 + 3)), false)); })
                .flat()),
            width: canvas.width,
            height: canvas.height,
        };
    }
    catch (_a) {
        console.error("Failed to load image, likely due to CORS issues.");
        return { width: canvas.width, height: canvas.height };
    }
};
var point2index = function (point, width) {
    return point.y * width + point.x;
};
var compare = function (hsv0, hsv1, threshold2) {
    if (hsv0.length !== 3 || hsv1.length !== 3) {
        throw "These points do not have the same number of color values.";
    }
    var _a = __read(hsv0, 3), h0 = _a[0], s0 = _a[1], v0 = _a[2];
    var _b = __read(hsv1, 3), h1 = _b[0], s1 = _b[1], v1 = _b[2];
    var dh = Math.min(Math.abs(h1 - h0), 255 - Math.abs(h1 - h0)) * 2;
    var ds = Math.abs(s1 - s0);
    var dv = Math.abs(v1 - v0);
    var distance = dh * dh + ds * ds + dv * dv;
    return distance <= threshold2;
};
var scalePoint = function (point, scale) {
    return {
        x: Math.round(point.x * scale.sx),
        y: Math.round(point.y * scale.sy),
    };
};
var fillHsv = function (point, image, options) {
    var threshold2 = Math.pow(options.threshold, 2);
    if (options.previous &&
        image.width * image.height !== options.previous.values.length)
        throw "Incompatible dimensions for mask (".concat(options.previous.values.length, ") and canvas (").concat(image.width, "x").concat(image.height, ").");
    var maskDimensions = options.previous
        ? options.previous.dimensions
        : { height: image.height, width: image.width };
    var mask = new Uint8ClampedArray(maskDimensions.width * maskDimensions.height);
    var pointInt = {
        x: Math.round(point.x * image.width),
        y: Math.round(point.y * image.height),
    };
    // It's possible that we need to edit
    // a mask that was originally drawn using
    // a differently sized canvas. This allows
    // for that conversion.
    var scale = {
        sx: maskDimensions.width / image.width,
        sy: maskDimensions.height / image.height,
    };
    var radiusInt = options.radius
        ? {
            dx: Math.round(options.radius.dx * image.width),
            dy: Math.round(options.radius.dy * image.height),
        }
        : {
            dx: 0,
            dy: 0,
        };
    var matchedValue = nodeStatusToValue["matched"];
    var operations = {
        equals: function (a, b) { return compare(Array.from(a), Array.from(b), threshold2); },
        isInBounds: function (point) {
            return point.x < image.width &&
                point.y < image.height &&
                point.x >= 0 &&
                point.y >= 0;
        },
        getImageValue: function (point) {
            var _a;
            var start = point2index(point, image.width) * hsvChannels;
            return (_a = image.hsv) === null || _a === void 0 ? void 0 : _a.slice(start, start + hsvChannels);
        },
        getMatchValue: function (point) {
            return valueToNodeStatus[mask[point2index(scalePoint(point, scale), maskDimensions.width)]];
        },
        setMatchValue: function (point, status) {
            return (mask[point2index(scalePoint(point, scale), maskDimensions.width)] =
                nodeStatusToValue[status]);
        },
    };
    var points = [];
    for (var dx = 0; dx <= radiusInt.dx; dx++) {
        var _loop_2 = function (dy) {
            points = points.concat((dx === 0 ? [dx] : [dx, -dx])
                .map(function (dxc) {
                return (dy === 0 ? [dy] : [dy, -dy]).map(function (dyc) {
                    return { x: pointInt.x + dxc, y: pointInt.y + dyc };
                });
            })
                .flat());
        };
        for (var dy = 0; dy <= radiusInt.dy; dy++) {
            _loop_2(dy);
        }
    }
    fill(points, operations, maxSegmentationIters);
    // Set mask to be matched if either the memo or the mask are matched.
    if (options.previous) {
        options.previous.values.forEach(function (v, i) {
            if (v === matchedValue) {
                mask[i] = v;
            }
        });
    }
    return mask;
};
var counts2values = function (counts) {
    return new Uint8ClampedArray(counts
        .map(function (length, index) {
        return Array.from(Array(length).keys()).map(function () { return (index % 2 === 0 ? 255 : 0); });
    })
        .flat());
};
var values2counts = function (values) {
    return values.reduce(function (memo, value) {
        if (((memo.length - 1) % 2 == 0) == (value == 255)) {
            memo[memo.length - 1] += 1;
        }
        else {
            memo.push(1);
        }
        return memo;
    }, [0]);
};
var findMaskByPoint = function (point, masks) {
    return findLastIndex(masks, function (mask) {
        return (valueToNodeStatus[mask.map.values[Math.round(point.y * mask.map.dimensions.height) *
            mask.map.dimensions.width +
            Math.round(point.x * mask.map.dimensions.width)]] == "matched");
    });
};

var pct2css = function (pct) { return "".concat(100 * pct, "%"); };
var insertOrAppend = function (arr, item, idx, save) {
    return (save ? [item] : []).concat(arr
        .slice(0, idx > -1 ? idx : undefined)
        .concat(idx > -1 ? arr.slice(idx + 1) : []));
};
var copy = function (o) {
    try {
        return JSON.parse(JSON.stringify(o));
    }
    catch (_a) {
        throw "Failed to copy object: ".concat(o);
    }
};
var labels2string = function (labels) {
    return Object.keys(labels)
        .filter(function (k) { return labels[k].length == 1; })
        .map(function (k) { return "".concat(k, ": ").concat(labels[k][0]); })
        .join(", ");
};
var epsilon = 1e-4;
var labels2draft = function (labels) {
    return {
        image: copy((labels === null || labels === void 0 ? void 0 : labels.image) || {}),
        polygons: copy((labels === null || labels === void 0 ? void 0 : labels.polygons) || []),
        masks: ((labels === null || labels === void 0 ? void 0 : labels.masks) || []).map(function (m) {
            return __assign(__assign({}, m), { map: {
                    dimensions: m.map.dimensions,
                    values: counts2values(m.map.counts),
                } });
        }),
        dimensions: labels.dimensions ? copy(labels.dimensions) : undefined,
        boxes: copy((labels === null || labels === void 0 ? void 0 : labels.boxes) || []),
    };
};
var fixBox = function (box) {
    var pt1 = box.pt1;
    var pt2 = box.pt2 || box.pt1;
    return __assign(__assign({}, box), { pt1: {
            x: Math.min(pt1.x, pt2.x),
            y: Math.min(pt1.y, pt2.y),
        }, pt2: {
            x: Math.max(pt1.x, pt2.x),
            y: Math.max(pt1.y, pt2.y),
        } });
};
var draft2labels = function (labels) {
    return __assign(__assign({}, labels), { boxes: labels.boxes.map(fixBox), masks: labels.masks.map(function (m) {
            return __assign(__assign({}, m), { map: {
                    dimensions: m.map.dimensions,
                    counts: values2counts(m.map.values),
                } });
        }) });
};
var insertOrAppendByTimestamp = function (current, existing) {
    return insertOrAppend(existing, current, existing.findIndex(function (i) { return i.timestamp === current.timestamp; }), true).sort(function (a, b) { return (a.timestamp > b.timestamp ? 1 : -1); });
};
var shortcutify = function (initial) {
    var taken = initial.reduce(function (memo, entry) {
        return entry.options
            ? memo.concat(entry.options.filter(function (o) { return o.shortcut; }).map(function (o) { return o.shortcut; }))
            : memo;
    }, []);
    return initial.map(function (entry) {
        return __assign(__assign({}, entry), { options: entry.options
                ? entry.options.map(function (option) {
                    var shortcut = option.shortcut;
                    if (!shortcut) {
                        shortcut = __spreadArray([], __read(option.name.toLowerCase()), false).find(function (c) { return taken.indexOf(c) == -1; });
                        if (shortcut) {
                            taken.push(shortcut);
                        }
                    }
                    return __assign(__assign({}, option), { shortcut: shortcut });
                })
                : undefined });
    });
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_debounce = debounce;

var computeDistance = function (pt1, pt2, dimensions) {
    return Math.pow((pt1.x - pt2.x) * (dimensions ? dimensions.width : 1), 2) +
        Math.pow((pt1.y - pt2.y) * (dimensions ? dimensions.height : 1), 2);
};
var isPolygonClosed = function (candidate, points) {
    if (!points || points.length === 0)
        return false;
    var start = points[0];
    points[points.length - 1];
    //if (start.x === end.x && start.y === end.y) return true;
    if (candidate.x === start.x && candidate.y === start.y)
        return true;
    return false;
};
var snapPolygonCoords = function (cursor, drawing, dimensions) {
    if (!drawing.active ||
        drawing.mode !== "polygons" ||
        drawing.active.region.points.length == 0)
        return cursor;
    var start = drawing.active.region.points[0];
    var distance = Math.sqrt(computeDistance(start, cursor.coords, dimensions));
    if (distance > 10)
        return cursor;
    return __assign(__assign({}, cursor), { coords: start });
};

var DEFAULT_MAX_CANVAS_SIZE = 512;
var handleMediaClick = function (draft, point, refs, altKey, selected, maxCanvasSize, idx) {
    var _a;
    var drawing = draft.drawing;
    if (drawing.active && drawing.active.idx > -1) {
        // We have selected a pre-existing label and the user has
        // re-clicked. This results in de-selection.
        return __assign(__assign({}, draft), { drawing: __assign(__assign({}, drawing), { active: undefined }), labels: __assign(__assign({}, draft.labels), (_a = {}, _a[drawing.mode] = !drawing.active
                ? draft.labels[drawing.mode]
                : insertOrAppend(draft.labels[drawing.mode], draft.drawing.active.region, draft.drawing.active.idx, true), _a)) });
    }
    if (drawing.mode == "masks") {
        var canvas = draft.canvas ||
            img2hsv(refs.source.current, refs.canvas.current, maxCanvasSize || DEFAULT_MAX_CANVAS_SIZE);
        var image = __assign(__assign({}, canvas), { hsv: drawing.flood ? canvas.hsv : undefined });
        if (drawing.mode === "masks" && drawing.flood && !image.hsv) {
            throw "Flood fill failed due to cross-origin media. Please disable flood fill.";
        }
        var fillOptions = {
            previous: drawing.active ? drawing.active.region.map : undefined,
            radius: {
                dx: draft.cursor.radius / refs.source.current.clientWidth,
                dy: draft.cursor.radius / refs.source.current.clientHeight,
            },
            threshold: draft.cursor.threshold,
        };
        if (drawing.active) {
            // There's already an active mask and we are adding to it.
            drawing.active = __assign(__assign({}, drawing.active), { region: __assign(__assign({}, drawing.active.region), { map: __assign(__assign({}, drawing.active.region.map), { values: fillHsv(point, image, fillOptions) }) }) });
        }
        else {
            // We are either creating a new mask or selecting an existing one.
            var maskIdx = findMaskByPoint(point, draft.labels.masks);
            if (maskIdx !== -1 && !altKey) {
                // We are selecting an existing one.
                drawing.active = {
                    idx: maskIdx,
                    region: draft.labels.masks[maskIdx],
                };
            }
            else {
                // We are creating a new one.
                drawing.active = {
                    idx: -1,
                    region: {
                        map: {
                            dimensions: {
                                width: canvas.width,
                                height: canvas.height,
                            },
                            values: fillHsv(point, image, fillOptions),
                        },
                        labels: {},
                    },
                };
            }
        }
        return __assign(__assign({}, draft), { canvas: canvas, drawing: drawing });
    }
    else if (drawing.mode === "polygons") {
        if (drawing.active) {
            // We're adding a point to an existing polygon.
            drawing.active = __assign(__assign({}, drawing.active), { region: __assign(__assign({}, drawing.active.region), { points: drawing.active.region.points.concat([
                        snapPolygonCoords(__assign(__assign({}, draft.cursor), { coords: point }), drawing, {
                            width: refs.source.current.clientWidth,
                            height: refs.source.current.clientHeight,
                        }).coords,
                    ]) }) });
        }
        else if (selected && !altKey && idx !== undefined) {
            // We just selected a polygon.
            drawing.active = {
                region: selected,
                idx: idx,
            };
        }
        else {
            // We are creating a brand new polygon.
            drawing.active = {
                region: { points: [point], labels: {} },
                idx: -1,
            };
        }
        return __assign(__assign({}, draft), { drawing: drawing });
    }
    else if (drawing.mode === "boxes") {
        if (drawing.active) {
            // We're changing an existing box.
            var pt1 = void 0;
            var pt2 = void 0;
            if (!drawing.active.region.pt2) {
                pt1 = drawing.active.region.pt1;
                pt2 = point;
            }
            else {
                var d1 = computeDistance(point, drawing.active.region.pt1);
                var d2 = computeDistance(point, drawing.active.region.pt2);
                if (d1 < d2) {
                    // We're closer to pt1 than pt2, so leave pt2 alone and
                    // change pt1.
                    pt1 = point;
                    pt2 = drawing.active.region.pt2;
                }
                else {
                    pt1 = drawing.active.region.pt1;
                    pt2 = point;
                }
            }
            drawing.active = __assign(__assign({}, drawing.active), { region: __assign(__assign({}, drawing.active.region), { pt1: pt1, pt2: pt2 }) });
        }
        else if (selected && !altKey && idx !== undefined) {
            // We just selected a polygon.
            drawing.active = {
                region: selected,
                idx: idx,
            };
        }
        else {
            // We are creating a brand new polygon.
            drawing.active = {
                region: { pt1: point, labels: {} },
                idx: -1,
            };
        }
        return __assign(__assign({}, draft), { drawing: drawing });
    }
};

var convertCoordinates = function (point, image) {
    if (!image) {
        throw Error("Requested mouse position without a ref.");
    }
    var _a = image.getBoundingClientRect(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    return {
        x: (point.x - window.scrollX - x) / width,
        y: (point.y - window.scrollY - y) / height,
    };
};
var useMediaLarge = function () {
    return (0,_mui_material__WEBPACK_IMPORTED_MODULE_1__.useMediaQuery)((0,_mui_material__WEBPACK_IMPORTED_MODULE_1__.useTheme)().breakpoints.up("sm"));
};
var useMediaEvent = function (func, elem, deps, time) {
    return react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        var debounced = time && time !== 0 ? lodash_debounce(func, time) : func;
        return function (event) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return debounced.apply(void 0, __spreadArray([convertCoordinates({
                    x: event.nativeEvent.pageX,
                    y: event.nativeEvent.pageY,
                }, elem.current),
                event], __read(args), false));
        };
    }, __spreadArray(__spreadArray([], __read((deps || [])), false), [elem], false));
};
var useKeyboardEvent = function (handler, deps) {
    var container = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext).container;
    var wrapped = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (event) {
        var _a, _b;
        var inElement = !!(event.target &&
            container.current &&
            container.current.contains(event.target));
        var inFocusingElement = !!(event.target &&
            event.target.closest(".react-image-labeler-input-target"));
        var nodeName = (_a = event.target) === null || _a === void 0 ? void 0 : _a.nodeName;
        var editable = ((_b = event.target) === null || _b === void 0 ? void 0 : _b.contentEditable) === "true";
        if (
        // We never take input if we're not in our element
        !inElement ||
            // or from textarea nodes.
            nodeName === "TEXTAREA" ||
            // or from input nodes *unless* they're checkbox/radio buttons in our own form.
            (nodeName === "INPUT" && !(inFocusingElement && inElement)) ||
            // or from editable nodes.
            editable) {
            return;
        }
        handler(event);
    }, (deps || []).concat([handler, container]));
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        document.addEventListener("keydown", wrapped, false);
        return function () {
            document.removeEventListener("keydown", wrapped, false);
        };
    }, [wrapped]);
};
var delay = function (amount) {
    return new Promise(function (resolve) { return setTimeout(resolve, amount); });
};
var simulateClick = function (target, offset, disableBlur) {
    return __awaiter(void 0, void 0, void 0, function () {
        var _a, x, y, args;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!target)
                        return [2 /*return*/];
                    target.focus({ preventScroll: true });
                    target.classList.add("active");
                    _a = target.getBoundingClientRect(), x = _a.x, y = _a.y;
                    args = __assign({ bubbles: true, cancelable: true }, (offset
                        ? {
                            clientX: x + offset.x,
                            clientY: y + offset.y,
                        }
                        : {}));
                    target.dispatchEvent(new MouseEvent("mousedown", args));
                    target.dispatchEvent(new MouseEvent("mouseup", args));
                    return [4 /*yield*/, delay(100)];
                case 1:
                    _b.sent();
                    target.dispatchEvent(new MouseEvent("click", args));
                    target.classList.remove("active");
                    target.blur();
                    return [2 /*return*/];
            }
        });
    });
};
// From https://github.com/Hermanya/use-interval/blob/master/src/index.tsx
var noop = function () { };
var useInterval = function (callback, delay, immediate, deps) {
    var savedCallback = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(noop);
    // Remember the latest callback.
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        savedCallback.current = callback;
    });
    // Execute callback if immediate is set.
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        if (!immediate)
            return;
        if (delay === null || delay === false)
            return;
        savedCallback.current();
    }, [immediate]);
    // Set up the interval.
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        if (delay === null || delay === false)
            return undefined;
        var tick = function () { return savedCallback.current(); };
        var id = setInterval(tick, delay);
        return function () { return clearInterval(id); };
    }, [delay].concat(deps || []));
};
var useLoader = function (loader, src) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState({
        disableControls: false,
        disableContents: !!src,
        timestamp: new Date().getTime(),
        mediaState: undefined,
    }), 2), state = _a[0], setState = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(src), 2), visibleSource = _b[0], setVisibleSource = _b[1];
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        if (src !== visibleSource) {
            setState({
                disableControls: false,
                disableContents: !!src,
                timestamp: new Date().getTime(),
                mediaState: state.mediaState,
            });
            setVisibleSource(src);
        }
    }, [src]);
    useInterval(function () {
        return state.disableContents &&
            !state.disableControls &&
            new Date().getTime() - state.timestamp > 250
            ? setState(__assign(__assign({}, state), { disableControls: true }))
            : null;
    }, 100, true);
    return {
        visibleSource: visibleSource,
        mediaState: state.mediaState,
        disableControls: state.disableControls,
        disableContents: state.disableContents,
        loader: react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (event) { return __awaiter(void 0, void 0, void 0, function () {
            var _a;
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = setState;
                        _b = {};
                        return [4 /*yield*/, loader(event)];
                    case 1:
                        _a.apply(void 0, [(_b.mediaState = _c.sent(),
                                _b.timestamp = new Date().getTime(),
                                _b.disableControls = false,
                                _b.disableContents = false,
                                _b)]);
                        return [2 /*return*/];
                }
            });
        }); }, [loader, visibleSource]),
    };
};
var useDraftLabelState = function (labels, deps) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState({
        labels: labels2draft(labels || {}),
        dirty: false,
        canvas: null,
        cursor: {
            radius: 5,
            threshold: 10,
            coords: undefined,
        },
        drawing: {
            mode: "boxes",
        },
    }), 2), draft = _a[0], setDraft = _a[1];
    var resetDraft = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {
        return setDraft(__assign(__assign({}, draft), { labels: labels2draft(labels || {}), dirty: false, canvas: null, drawing: {
                mode: draft.drawing.mode,
                flood: draft.drawing.mode === "masks" ? draft.drawing.flood : undefined,
            } }));
    }, [labels, draft]);
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        resetDraft();
    }, [labels].concat(deps || []));
    return { draft: draft, setDraft: setDraft, resetDraft: resetDraft };
};
var useMediaMouseCallbacks = function (draft, setDraft, refs, showCursor, maxCanvasSize) {
    var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext), setFocus = _a.setFocus, setToast = _a.setToast;
    return {
        onClick: useMediaEvent(function (point, event, selected, idx) {
            setFocus();
            if (!showCursor)
                return;
            try {
                setDraft(handleMediaClick(draft, point, refs, event.altKey, selected, maxCanvasSize, idx));
            }
            catch (e) {
                setToast(e);
            }
        }, refs.source, [draft]),
        onMouseMove: useMediaEvent(function (coords) {
            if (!showCursor)
                return;
            setDraft(__assign(__assign({}, draft), { cursor: snapPolygonCoords(__assign(__assign({}, draft.cursor), { coords: coords }), draft.drawing, {
                    width: refs.source.current.clientWidth,
                    height: refs.source.current.clientHeight,
                }) }));
        }, refs.source, [draft], 1),
    };
};
var labels4timestamp = function (labels, timestamp) {
    if (!labels)
        return { timestamp: timestamp, end: undefined, labels: {} };
    return (labels.filter(function (l) { return l.timestamp === timestamp; })[0] || {
        timestamp: timestamp,
        end: undefined,
        labels: {},
    });
};
var usePlaybackState = function (refs, labels) {
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(__assign({ paused: true, playbackRate: 0, muted: false }, labels4timestamp(labels, 0))), 2), playbackState = _a[0], setPlaybackState = _a[1];
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        return setPlaybackState(__assign(__assign({}, playbackState), labels4timestamp(labels, refs.main.current.currentTime)));
    }, [labels]);
    useInterval(function () {
        if (refs.main.current &&
            !(refs.main.current.paused === playbackState.paused &&
                refs.main.current.currentTime === playbackState.timestamp &&
                refs.main.current.playbackRate === playbackState.playbackRate))
            setPlaybackState(__assign(__assign(__assign({}, playbackState), { paused: refs.main.current.paused, playbackRate: refs.main.current.playbackRate, timestamp: refs.main.current.currentTime }), (refs.main.current.paused
                ? labels4timestamp(labels, refs.main.current.currentTime)
                : { end: undefined, labels: {} })));
        if (refs.secondaryThumbnail.current &&
            playbackState.end &&
            refs.secondaryThumbnail.current.currentTime !== playbackState.end)
            refs.secondaryThumbnail.current.currentTime = playbackState.end;
        ["main", "mini"].map(function (k) {
            if (refs[k].current && refs[k].current.muted !== playbackState.muted) {
                refs[k].current.muted = playbackState.muted;
            }
        });
    }, 10, true);
    var toggleMute = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () { return setPlaybackState(__assign(__assign({}, playbackState), { muted: !playbackState.muted })); }, [playbackState]);
    var setPlayback = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (playbackRate, timestamp, end) {
        if (playbackRate == 0) {
            refs.main.current.pause();
            refs.mini.current.pause();
        }
        else if (playbackRate > 0) {
            refs.main.current.playbackRate = playbackRate;
            refs.mini.current.playbackRate = playbackRate;
            if (refs.main.current.paused) {
                refs.main.current.play();
                refs.mini.current.play();
            }
        }
        else if (playbackRate < 0) {
            throw "Rewinding is not supported.";
        }
        if (timestamp !== undefined) {
            refs.main.current.currentTime = timestamp;
            refs.mini.current.currentTime = timestamp;
        }
        if (end !== undefined) {
            setPlaybackState(__assign(__assign({}, playbackState), { end: end }));
        }
    }, [refs, playbackState]);
    return {
        playbackState: playbackState,
        setPlaybackState: setPlayback,
        toggleMute: toggleMute,
    };
};

var MAP_SIZE = 96;
var MediaViewer = function (_a) {
    var children = _a.children, media = _a.media, size = _a.size, controls = _a.controls, loading = _a.loading, onMouseLeave = _a.onMouseLeave, _b = _a.maxViewHeight, maxViewHeight = _b === void 0 ? 512 : _b;
    var setFocus = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext).setFocus;
    var refs = {
        viewport: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        minimap: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        media: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
    };
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState({
        zoom: 100,
        pos: { x: 0, y: 0 },
        viewportSize: undefined,
    }), 2), state = _c[0], setState = _c[1];
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () { return setState(__assign(__assign({}, state), { pos: { x: 0, y: 0 } })); }, [loading]);
    useInterval(function () {
        if (refs.viewport.current &&
            (!state.viewportSize ||
                refs.viewport.current.clientHeight !== state.viewportSize.height ||
                refs.viewport.current.clientWidth !== state.viewportSize.width)) {
            setState(__assign(__assign({}, state), { viewportSize: {
                    width: refs.viewport.current.clientWidth,
                    height: refs.viewport.current.clientHeight,
                } }));
        }
    }, 100, true);
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        var _a;
        if (!size) {
            return;
        }
        setState(__assign(__assign({}, state), { zoom: 100 *
                Math.min((((_a = refs.viewport.current) === null || _a === void 0 ? void 0 : _a.clientWidth) || maxViewHeight) / size.width, maxViewHeight / size.height) }));
    }, [size]);
    var elementSize = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        return size
            ? {
                width: (size.width * state.zoom) / 100,
                height: (size.height * state.zoom) / 100,
            }
            : undefined;
    }, [state.zoom, size]);
    var minimapSize = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        if (!elementSize)
            return null;
        var scale = elementSize
            ? MAP_SIZE / Math.max(elementSize.width, elementSize.height)
            : null;
        return {
            width: scale * elementSize.width,
            height: scale * elementSize.height,
        };
    }, [elementSize]);
    var margin = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        return state.viewportSize && elementSize
            ? {
                x: Math.min(state.viewportSize.width, elementSize.width) /
                    elementSize.width /
                    2,
                y: Math.min(state.viewportSize.height, elementSize.height) /
                    elementSize.height /
                    2,
            }
            : { x: 0, y: 0 };
    }, [state]);
    var clip = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        return {
            left: state.pos.x * ((elementSize === null || elementSize === void 0 ? void 0 : elementSize.width) || 0),
            top: state.pos.y * ((elementSize === null || elementSize === void 0 ? void 0 : elementSize.height) || 0),
        };
    }, [state.pos, elementSize]);
    var setPos = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (point) {
        if (!margin) {
            console.error("Tried to set position without available data.");
            return;
        }
        setState(__assign(__assign({}, state), { pos: {
                x: Math.min(Math.max(point.x, 0), Math.max(0, 1 - 2 * margin.x)),
                y: Math.min(Math.max(point.y, 0), Math.max(0, 1 - 2 * margin.y)),
            } }));
    }, [state, margin]);
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        var offsetX = Math.min(1 - (state.pos.x + 2 * margin.x), 0);
        var offsetY = Math.min(1 - (state.pos.y + 2 * margin.y), 0);
        if (offsetX || offsetY) {
            setPos({ x: state.pos.x + offsetX, y: state.pos.y + offsetY });
        }
    }, [margin]);
    var onMapClick = useMediaEvent(function (point) {
        setFocus();
        setPos({ x: point.x - margin.x, y: point.y - margin.y });
    }, refs.minimap, [setPos, margin, setFocus], 5);
    var onImageScroll = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (event) {
        if (!elementSize)
            return;
        event.preventDefault();
        event.stopPropagation();
        if (!event.ctrlKey) {
            setPos({
                x: state.pos.x + event.deltaX / elementSize.width,
                y: state.pos.y + event.deltaY / elementSize.height,
            });
        }
        else {
            setState(__assign(__assign({}, state), { zoom: state.zoom - event.deltaY }));
        }
        return false;
    }, [state, elementSize]);
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        if (!refs.media.current)
            return;
        refs.media.current.addEventListener("wheel", onImageScroll, {
            passive: false,
        });
        return function () {
            if (!refs.media.current)
                return;
            refs.media.current.removeEventListener("wheel", onImageScroll);
        };
    }, [refs.media, onImageScroll]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { className: "media-viewer" },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { mb: 2 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { className: "viewport", style: {
                    position: "relative",
                    overflow: "hidden",
                    height: Math.min(maxViewHeight, elementSize ? elementSize.height : maxViewHeight),
                }, ref: refs.viewport },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClickTarget, null),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
                    loading ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.CircularProgress, { style: {
                            position: "absolute",
                            left: "50%",
                            right: "50%",
                            top: "50%",
                            bottom: "50%",
                        } })) : null,
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { className: "media", onMouseLeave: loading ? null : onMouseLeave, ref: refs.media, style: {
                            position: "absolute",
                            overflow: "hidden",
                            clip: "rect(".concat(clip.top, "px, auto, auto, ").concat(clip.left, "px)"),
                            left: "".concat(-clip.left, "px"),
                            top: "".concat(-clip.top, "px"),
                        } },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { className: "raw", style: loading
                                ? { width: 0, height: 0, overflow: "hidden" }
                                : elementSize || { width: 0, height: 0 } },
                            children,
                            media.main)))),
            controls || null),
        loading || !state.viewportSize || !elementSize ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { height: (minimapSize === null || minimapSize === void 0 ? void 0 : minimapSize.height) || MAP_SIZE } })) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { className: "controls", style: {
                display: "grid",
                gridTemplateColumns: "".concat((minimapSize === null || minimapSize === void 0 ? void 0 : minimapSize.width) || MAP_SIZE, "px 1fr"),
                gridTemplateRows: "auto",
                gridTemplateAreas: '"minimap zoom"',
                gridColumnGap: 10,
            } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Paper, { className: "minimap", style: __assign(__assign({}, minimapSize), { position: "relative" }), onClick: onMapClick },
                children,
                media.mini,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: {
                        outline: "2px solid red",
                        outlineOffset: "-1px",
                        position: "absolute",
                        left: pct2css(state.pos.x),
                        top: pct2css(state.pos.y),
                        width: pct2css(Math.min(1 - state.pos.x, state.viewportSize.width / elementSize.width)),
                        height: pct2css(Math.min(1 - state.pos.y, state.viewportSize.height / elementSize.height)),
                    } }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { ref: refs.minimap, className: "hover-target", style: __assign(__assign({ position: "absolute", top: 0 }, minimapSize), { display: "block" }) })),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RangeSlider, { name: "Zoom", className: "zoom", min: 1, max: Math.max(500, state.zoom), width: "100%", value: state.zoom, onChange: function (zoom) {
                    return setState(__assign(__assign({}, state), { zoom: zoom }));
                } })))));
};

// Process change to a selection for a label.
/**
 * @param value - The value that has been selected.
 * @param selected - A list of current selected items.
 * @param multiple - Whether this field allows multiple selection.
 * @returns An updated list of selected values.
 */
var processSelectionChange = function (value, selected, multiple) {
    return selected && selected.indexOf(value) > -1
        ? multiple
            ? selected.filter(function (v) { return v != value; })
            : []
        : multiple
            ? (selected || []).concat([value])
            : [value];
};
var buildOptionsList = function (selected, options) {
    return options.concat(selected
        ? selected
            .filter(function (s) { return (options || []).findIndex(function (o) { return o.name === s; }) == -1; })
            .map(function (s) {
            return { name: s, shortcut: "" };
        })
        : []);
};
var LabelPanelEntry = function (_a) {
    var config = _a.config, selected = _a.selected, setSelected = _a.setSelected, disabled = _a.disabled, editConfig = _a.editConfig;
    var availableOptions = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        return config.options || (config.multiple && config.freeform)
            ? buildOptionsList(selected || [], config.options || [])
            : undefined;
    }, [config.options, selected]);
    var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);
    var setFocus = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext).setFocus;
    var keyIndexMap = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        return availableOptions
            ? availableOptions.reduce(function (map, o, i) {
                var _a;
                return o.shortcut ? __assign(__assign({}, map), (_a = {}, _a[o.shortcut] = i, _a)) : map;
            }, {})
            : {};
    }, [availableOptions]);
    var toggleSelected = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (o) { return setSelected(processSelectionChange(o, selected, config.multiple)); }, [selected, config, setSelected]);
    useKeyboardEvent(function (event) {
        if (
        // Block if a modifier key is used, or if we've disabled shortcuts,
        // or if the keyOptionMap is empty (meaning there are no shortcuts).
        event.ctrlKey ||
            event.shiftKey ||
            !keyIndexMap) {
            return;
        }
        var idx = keyIndexMap[event.key];
        if (idx > -1) {
            var target = ref.current.querySelector(".react-image-labeler-input-target[data-index='".concat(idx, "'] input"));
            simulateClick(target);
            event.preventDefault();
            event.stopPropagation();
            setFocus();
        }
    }, [keyIndexMap, ref, setFocus]);
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState({
        freeform: availableOptions || config.multiple || !config.freeform || !selected
            ? ""
            : selected[0],
    }), 2), state = _b[0], setState = _b[1];
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        return setState({
            freeform: availableOptions || config.multiple || !config.freeform || !selected
                ? ""
                : selected[0],
        });
    }, [selected]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormControl, { sx: { ml: 3, mr: 3, mt: 0, mb: 3 }, component: "fieldset", variant: "standard", className: "label-panel-entry", disabled: !!disabled, name: config.name },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormLabel, { component: "legend", className: "label-panel-entry-label" },
            config.displayName || config.name,
            " ",
            editConfig ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.IconButton, { "aria-label": "edit ".concat(config.name), className: "edit-label-entry", onClick: editConfig },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.Edit, null))) : null),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormGroup, { ref: ref }, (availableOptions || []).map(function (o, i) {
            var controlProps = {
                checked: !!(selected && selected.indexOf(o.name) > -1),
                onChange: function () { return toggleSelected(o.name); },
                name: o.name,
                className: "react-image-labeler-input-target",
            };
            var label = "".concat(o.displayName || o.name, " ").concat(o.shortcut ? "(".concat(o.shortcut, ")") : "");
            return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormControlLabel, { className: "label-panel-entry-option-label", key: i, control: config.multiple ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Checkbox, __assign({}, controlProps, { "data-index": i }))) : (
                // Add the onClick so we can de-select radio selections.
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Radio, __assign({}, controlProps, { "data-index": i, onClick: controlProps.onChange }))), color: "primary", label: label }));
        })),
        config.freeform ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Input, { value: state.freeform, name: "".concat(config.name, "-freeform"), placeholder: config.multiple ? "Add new option" : undefined, onKeyPress: function (event) {
                if (event.key === "Enter") {
                    if (config.multiple || availableOptions) {
                        toggleSelected(state.freeform);
                        setState({
                            freeform: "",
                        });
                    }
                    else {
                        setFocus();
                    }
                    event.preventDefault();
                }
            }, onChange: function (event) {
                setState(__assign(__assign({}, state), { freeform: event.target.value }));
                if (!config.multiple && !availableOptions) {
                    toggleSelected(event.target.value);
                }
                event.preventDefault();
                event.stopPropagation();
            } })) : null));
};

var LabelPanel = function (_a) {
    var config = _a.config, labels = _a.labels, setLabels = _a.setLabels, disabled = _a.disabled, editConfig = _a.editConfig;
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { ml: -3, mr: -3 }, config.map(function (c, i) { return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanelEntry, { key: c.name, config: c, disabled: disabled, editConfig: editConfig ? function () { return editConfig(i); } : undefined, selected: labels[c.name], setSelected: function (selected) {
            var _a;
            return setLabels(__assign(__assign({}, labels), (_a = {}, _a[c.name] = selected, _a)));
        } })); })));
};

var ConfigEditor = function (_a) {
    var open = _a.open, existing = _a.existing, onSave = _a.onSave, onClose = _a.onClose;
    var emptyState = {
        properties: [],
        displayName: "",
        name: "",
        level: "image",
        options: [],
        mockSelected: [],
    };
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(emptyState), 2), state = _b[0], setState = _b[1];
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        var _a, _b, _c;
        return existing
            ? setState(__assign(__assign({}, emptyState), { properties: []
                    .concat(((_a = existing === null || existing === void 0 ? void 0 : existing.config) === null || _a === void 0 ? void 0 : _a.freeform) ? ["freeform"] : [])
                    .concat(((_b = existing === null || existing === void 0 ? void 0 : existing.config) === null || _b === void 0 ? void 0 : _b.multiple) ? ["multiple"] : []), displayName: existing.config.displayName || "", name: (existing.config.name || ""), level: existing.level || "image", options: ((_c = existing === null || existing === void 0 ? void 0 : existing.config.options) === null || _c === void 0 ? void 0 : _c.map(function (o) { return o.displayName || o.name; })) ||
                    [] }))
            : null;
    }, [existing]);
    var valid = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        return state.name &&
            (state.properties.indexOf("freeform") > -1 || state.options.length > 0);
    }, [state]);
    var options = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () {
        return state.options.length > 0
            ? state.options.map(function (o) {
                return __assign({ name: o }, ((existing === null || existing === void 0 ? void 0 : existing.config.options)
                    ? existing.config.options.find(function (e) { return (e.displayName || e.name) === o; }) || {}
                    : {}));
            })
            : undefined;
    }, [state, existing]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Modal, { open: open, "aria-describedby": "add-or-update-new-label-entry-description" },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: {
                p: 2,
                position: "absolute",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                bgcolor: "background.paper",
                border: "2px solid #000",
                boxShadow: 24,
            } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Typography, { id: "add-or-update-new-label-entry-description", sx: { mb: 1 } }, existing
                ? "Edit Label Configuration"
                : "Add New Label Configuration"),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { ml: -3, mr: -3 },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanelEntry, { setSelected: function (_a) {
                        var _b = __read(_a, 1), name = _b[0];
                        return setState(__assign(__assign({}, state), { name: name }));
                    }, selected: [state.name], disabled: !!existing, config: { multiple: false, freeform: true, name: "Name" } }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanelEntry, { setSelected: function (_a) {
                        var _b = __read(_a, 1), displayName = _b[0];
                        return setState(__assign(__assign({}, state), { displayName: displayName }));
                    }, selected: [state.displayName], disabled: !!existing, config: { multiple: false, freeform: true, name: "Display Name" } }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Divider, { sx: { mb: 2 } }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanelEntry, { disabled: !!existing, setSelected: function (_a) {
                        var _b = __read(_a, 1), level = _b[0];
                        return setState(__assign(__assign({}, state), { level: level || state.level }));
                    }, selected: [state.level], config: {
                        options: [
                            { name: "image", displayName: "Image" },
                            { name: "regions", displayName: "Regions" },
                        ],
                        multiple: false,
                        freeform: false,
                        name: "Level",
                    } }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanelEntry, { setSelected: function (properties) { return setState(__assign(__assign({}, state), { properties: properties })); }, selected: state.properties, config: {
                        options: [
                            { name: "freeform", displayName: "Freeform" },
                            { name: "multiple", displayName: "Multiple" },
                        ],
                        multiple: true,
                        freeform: false,
                        name: "Type",
                    } }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanelEntry, { setSelected: function (options) { return setState(__assign(__assign({}, state), { options: options })); }, selected: state.options, config: {
                        options: [],
                        multiple: true,
                        freeform: true,
                        name: "Options",
                    } })),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ButtonGroup, { size: "small", "aria-label": "label editing control menu" },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { disabled: !valid, onClick: function () {
                        onSave({
                            name: state.name,
                            displayName: state.displayName,
                            multiple: state.properties.indexOf("multiple") > -1,
                            freeform: state.properties.indexOf("freeform") > -1,
                            options: options,
                        }, state.level);
                        setState(emptyState);
                    } }, "Save"),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { onClick: function () {
                        onClose();
                        setState(emptyState);
                    } }, "Cancel")),
            valid ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Divider, { sx: { mt: 2, mb: 2 } }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Typography, null, "Your new label configuration will look like the following."),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { ml: -3, mr: -3, mt: 1 } },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanelEntry, { selected: state.mockSelected, setSelected: function (selected) {
                            return setState(__assign(__assign({}, state), { mockSelected: selected }));
                        }, config: {
                            name: state.name,
                            displayName: state.displayName,
                            options: options,
                            multiple: state.properties.indexOf("multiple") > -1,
                            freeform: state.properties.indexOf("freeform") > -1,
                        } })))) : null)));
};

var ControlMenu = function (_a) {
    var _b, _c;
    var draft = _a.draft, disabled = _a.disabled, callbacks = _a.callbacks, showNavigation = _a.showNavigation, setDraft = _a.setDraft, other = __rest(_a, ["draft", "disabled", "callbacks", "showNavigation", "setDraft"]);
    var theme = (0,_mui_material__WEBPACK_IMPORTED_MODULE_1__.useTheme)();
    var refs = Object.fromEntries([
        "next",
        "prev",
        "save",
        "finishRegion",
        "clearRegion",
        "delete",
        "ignore",
        "selectAll",
        "selectNone",
    ].map(function (key) { return [key, react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null)]; }));
    var isLarge = useMediaLarge();
    var config = {
        image: shortcutify(((_b = other.config) === null || _b === void 0 ? void 0 : _b.image) || []),
        regions: shortcutify(((_c = other.config) === null || _c === void 0 ? void 0 : _c.regions) || []),
    };
    var direction = isLarge ? other.direction : "column";
    var _d = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState({
        configEditorOpen: false,
        index: null,
    }), 2), state = _d[0], setState = _d[1];
    var _e = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(""), 2), error = _e[0], setError = _e[1];
    var setFocus = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext).setFocus;
    var finishPolygon = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (save) {
        var _a;
        return setDraft(__assign(__assign({}, draft), { dirty: true, labels: __assign(__assign({}, draft.labels), (_a = {}, _a[draft.drawing.mode] = !draft.drawing.active
                ? draft.labels[draft.drawing.mode]
                : insertOrAppend(draft.labels[draft.drawing.mode], draft.drawing.active.region, draft.drawing.active.idx, save), _a)), drawing: __assign(__assign({}, draft.drawing), { active: undefined }) }));
    }, [draft]);
    useKeyboardEvent(function (event) {
        if (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onKeyboardEvent) {
            callbacks.onKeyboardEvent(event);
        }
        var target;
        if (event.altKey) {
            return;
        }
        switch (event.key) {
            case "A":
                target = event.ctrlKey && event.shiftKey ? "selectNone" : null;
                break;
            case "a":
                target = event.ctrlKey && !event.shiftKey ? "selectAll" : null;
                break;
            case "ArrowRight":
                target = event.ctrlKey || event.shiftKey ? null : "next";
                if (draft.dirty && callbacks.onNext) {
                    setError("Please save or reset your changes before advancing to next image.");
                }
                break;
            case "ArrowLeft":
                target = "prev";
                if (draft.dirty && callbacks.onPrev) {
                    setError("Please save or reset your changes before returning to previous image.");
                }
                break;
            case "Enter":
                target =
                    event.ctrlKey || event.shiftKey
                        ? null
                        : draft.drawing.active
                            ? "finishRegion"
                            : "save";
                break;
            case "Backspace":
            case "Delete":
                target =
                    event.ctrlKey || event.shiftKey
                        ? null
                        : draft.drawing.active
                            ? "clearRegion"
                            : "delete";
                break;
            default:
                return;
        }
        if (target && refs[target].current) {
            simulateClick(refs[target].current).then(setFocus);
            event.preventDefault();
            event.stopPropagation();
        }
    }, [callbacks, state, draft, refs, setFocus]);
    var level = draft.drawing.active ? "regions" : "image";
    var activeConfig = config[level] || [];
    var allowRegionSelection = (config === null || config === void 0 ? void 0 : config.regions) && config.regions.length > 0;
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClickTarget, null),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Snackbar, { open: error !== "", autoHideDuration: 3000, onClose: function () { return setError(""); }, message: error }),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelPanel, { config: activeConfig, disabled: disabled, editConfig: (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSaveConfig)
                ? function (index) { return setState({ configEditorOpen: true, index: index }); }
                : null, labels: draft.drawing.active
                ? draft.drawing.active.region.labels
                : draft.labels.image, setLabels: function (current) {
                setDraft(__assign(__assign({}, draft), { dirty: true, labels: draft.drawing.active
                        ? draft.labels
                        : __assign(__assign({}, draft.labels), { image: current }), drawing: draft.drawing.active
                        ? __assign(__assign({}, draft.drawing), { active: __assign(__assign({}, draft.drawing.active), { region: __assign(__assign({}, draft.drawing.active.region), { labels: current }) }) }) : draft.drawing }));
            } }),
        Object.keys((draft.drawing.active ? config.regions : config.image) || [])
            .length > 0 ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Divider, { sx: { mb: 3 } })) : null,
        allowRegionSelection ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Stack, { alignContent: "center", direction: direction, spacing: 2 },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: {
                        borderRight: draft.drawing.mode === "masks"
                            ? "solid 1px ".concat(theme.palette.divider)
                            : undefined,
                    } },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormControl, null,
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormLabel, null, "Drawing Mode"),
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.RadioGroup, { row: true, className: "drawing-mode-select", onChange: function (event) {
                                return setDraft(__assign(__assign({}, draft), { drawing: {
                                        flood: event.target.value === "masks"
                                            ? draft.drawing.mode === "masks"
                                                ? draft.drawing.flood
                                                : false
                                            : undefined,
                                        mode: event.target.value,
                                    } }));
                            }, value: draft.drawing.mode }, [
                            ["boxes", "Box"],
                            ["polygons", "Polygon"],
                            ["masks", "Mask"],
                        ].map(function (_a, i) {
                            var _b = __read(_a, 2), name = _b[0], displayName = _b[1];
                            return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormControlLabel, { key: i, value: name, control: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Radio, { className: "drawing-mode-option", size: "small" }), label: displayName, disabled: !!draft.drawing.active || disabled }));
                        })))),
                draft.drawing.mode === "masks" ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: {
                        display: "grid",
                        gridTemplateColumns: direction == "row" ? "100px 200px 200px" : "100px 200px",
                        gridTemplateAreas: direction == "row"
                            ? '"toggle threshold size"'
                            : '"toggle threshold" "size size"',
                        gridTemplateRows: "auto",
                        columnGap: 25,
                    } },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.FormControlLabel, { style: { gridArea: "toggle" }, control: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Checkbox, { checked: draft.drawing.flood, onChange: function (event, flood) {
                                return setDraft(__assign(__assign({}, draft), { drawing: draft.drawing.mode === "masks"
                                        ? __assign(__assign({}, draft.drawing), { flood: flood }) : draft.drawing }));
                            } }), label: "Flood" }),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: { gridArea: "threshold", display: "inline-flex" } },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RangeSlider, { name: "Flood Threshold", value: draft.cursor.threshold, min: 1, disabled: !draft.drawing.flood, max: 20, width: "100%", "aria-label": "segmentation mask flood threshold", onChange: function (value) {
                                return setDraft(__assign(__assign({}, draft), { cursor: __assign(__assign({}, draft.cursor), { threshold: value }) }));
                            } })),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: { gridArea: "size", display: "inline-flex" } },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RangeSlider, { name: "Cursor Size", value: draft.cursor.radius, min: 1, max: 50, width: "100%", "aria-label": "segmentation mask labeling radius", onChange: function (value) {
                                return setDraft(__assign(__assign({}, draft), { cursor: __assign(__assign({}, draft.cursor), { radius: value }) }));
                            } })))) : null),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Divider, { sx: { mb: 2, mt: 2 } }))) : null,
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null, draft.drawing.active ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ButtonGroup, { fullWidth: true, size: "small", "aria-label": "region control menu" },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { ref: refs.finishRegion, onClick: function () { return finishPolygon(true); }, startIcon: "\u23CE", className: "finish-region" }, "Finish"),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { startIcon: "\u232B", onClick: function () { return finishPolygon(false); }, ref: refs.clearRegion }, "Delete"))) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Stack, { direction: direction, spacing: 2 },
            (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectAll) || (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectNone) ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ButtonGroup, { fullWidth: true, size: "small", "aria-label": "selection control menu", className: "selection-control" },
                (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectAll) ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { disabled: !(callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectAll) || disabled, onClick: callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectAll, startIcon: "\u2303A", ref: refs.selectAll, className: "select-all" }, "Select All")) : null,
                (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectNone) ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { disabled: !(callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectNone) || disabled, onClick: callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSelectNone, startIcon: "\u2303\u21E7A", ref: refs.selectNone, className: "select-none" }, "Select None")) : null)) : null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ButtonGroup, { fullWidth: true, size: "small", "aria-label": "label control menu" },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { ref: refs.save, disabled: !(callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave) || disabled, onClick: callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave, startIcon: "\u23CE", className: "save" }, "Save"),
                (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onIgnore) || (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onUnignore) ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { ref: refs.ignore, disabled: disabled, onClick: (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onIgnore) || (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onUnignore) }, (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onIgnore) ? "Ignore" : "Unignore")) : null,
                (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onDelete) ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { startIcon: "\u232B", ref: refs.delete, disabled: disabled, onClick: callbacks.onDelete }, "Delete")) : null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { disabled: disabled || !draft.dirty, onClick: callbacks === null || callbacks === void 0 ? void 0 : callbacks.onReset }, "Reset")),
            (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onPrev) || (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onNext) || showNavigation ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ButtonGroup, { size: "small", fullWidth: true, "aria-label": "navigation control menu" },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { startIcon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.KeyboardArrowLeft, null), ref: refs.prev, disabled: !(callbacks === null || callbacks === void 0 ? void 0 : callbacks.onPrev) || draft.dirty, onClick: callbacks.onPrev }, "Previous"),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { startIcon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.KeyboardArrowRight, null), ref: refs.next, disabled: !(callbacks === null || callbacks === void 0 ? void 0 : callbacks.onNext) || draft.dirty, onClick: callbacks.onNext }, "Next"))) : null,
            (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSaveConfig) ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ButtonGroup, { size: "small", "aria-label": "add new configuration menu", fullWidth: true },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, { className: "add-new-label", onClick: function () {
                        return setState({ index: null, configEditorOpen: true });
                    } }, "Add New Label Type"))) : null))),
        callbacks && callbacks.onSaveConfig ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ConfigEditor, { open: state.configEditorOpen, onClose: function () { return setState(__assign(__assign({}, state), { configEditorOpen: false })); }, existing: state.index !== null
                ? { config: activeConfig[state.index], level: level }
                : null, onSave: function (newLabelConfig, level) {
                var _a;
                if (state.index === null &&
                    (config[level] || []).find(function (c) { return c.name === newLabelConfig.name; })) {
                    throw "User attempted to add a config with the name of an existing config.";
                }
                var previous = config[level] || [];
                var index = state.index === null ? previous.length : state.index;
                callbacks.onSaveConfig(__assign(__assign({}, config), (_a = {}, _a[level] = previous
                    .slice(0, index)
                    .concat([newLabelConfig])
                    .concat(previous.slice(index + 1)), _a)));
                setState({ index: null, configEditorOpen: false });
            } })) : null));
};

var ImagePreloader = function (_a) {
    var images = _a.images;
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(0), 2), idx = _b[0], setIdx = _b[1];
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () { return setIdx(0); }, [images]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { width: 0, height: 0, overflow: "hidden" } }, images.map(function (src, sidx) {
        // Only show the img of the current index. After it loads,
        // advance the index forward. This makes preloading sequential.
        return sidx <= idx ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", { src: src, key: sidx, onLoad: function () { return setIdx(sidx + 1); } })) : null;
    })));
};

var interpretPoints = function (raw, cursor) {
    var points = cursor ? raw.concat([cursor]) : raw;
    var _a = __read([Math.min, Math.max]
        .map(function (agg) {
        return ["x", "y"].map(function (k) {
            return agg.apply(Math, points.map(function (p) { return p[k]; }));
        });
    })
        .flat(), 4), xmin = _a[0], ymin = _a[1], xmax = _a[2], ymax = _a[3];
    return { points: points, xmin: xmin, ymin: ymin, xmax: xmax, ymax: ymax };
};
var STROKE_WIDTH$1 = 2;
var Polygon = function (_a) {
    var polygon = _a.polygon, color = _a.color, candidate = _a.candidate, childProps = __rest(_a, ["polygon", "color", "candidate"]);
    var _b = interpretPoints(polygon.points, candidate), points = _b.points, xmin = _b.xmin, ymin = _b.ymin, xmax = _b.xmax, ymax = _b.ymax;
    var width = Math.max(xmax - xmin, epsilon);
    var height = Math.max(ymax - ymin, epsilon);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("svg", __assign({ className: "region polygon", width: pct2css(width), height: pct2css(height) }, childProps, { style: __assign({ position: "absolute", left: pct2css(xmin), top: pct2css(ymin), overflow: "visible" }, (childProps.style || {})) }),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("text", __assign({ x: 5, y: 5, fill: color }, childProps, { className: "box-text", fontFamily: "Roboto,Helvetica,Arial,sans-serif", alignmentBaseline: "hanging" }), labels2string(polygon.labels)),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("svg", __assign({}, childProps), Array.from(Array(points.length - 1).keys()).map(function (index) {
            return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("line", { key: index, stroke: color, strokeWidth: STROKE_WIDTH$1, x1: pct2css((points[index].x - xmin) / width), y1: pct2css((points[index].y - ymin) / height), x2: pct2css((points[index + 1].x - xmin) / width), y2: pct2css((points[index + 1].y - ymin) / height) }));
        }))));
};

var STROKE_WIDTH = 2;
var AlignedBox = function (_a) {
    var box = _a.box, color = _a.color, candidate = _a.candidate, childProps = __rest(_a, ["box", "color", "candidate"]);
    var pt1 = box.pt1;
    var pt2 = box.pt2 || candidate;
    if (!pt2) {
        return null;
    }
    var _b = __read([Math.min, Math.max]
        .map(function (agg) {
        return ["x", "y"].map(function (k) {
            return agg.apply(Math, [pt1, pt2].map(function (p) { return p[k]; }));
        });
    })
        .flat(), 4), xmin = _b[0], ymin = _b[1], xmax = _b[2], ymax = _b[3];
    var width = Math.max(xmax - xmin, epsilon);
    var height = Math.max(ymax - ymin, epsilon);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("svg", __assign({ className: "region box", width: pct2css(width), height: pct2css(height) }, childProps, { style: __assign({ position: "absolute", left: pct2css(xmin), top: pct2css(ymin), height: pct2css(height), overflow: "visible" }, (childProps.style || {})) }),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("text", __assign({ fill: color, className: "box-text", x: 5, y: 5, fontSize: "8pt" }, childProps, { fontFamily: "Roboto,Helvetica,Arial,sans-serif", dominantBaseline: "hanging" }), labels2string(box.labels)),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("rect", __assign({}, childProps, { x: 0, y: 0, fill: "none", width: "100%", height: "100%", stroke: color, strokeWidth: STROKE_WIDTH }))));
};

var RegionCursor = function (_a) {
    var radius = _a.radius, round = _a.round, x = _a.x, y = _a.y, crosshair = _a.crosshair, other = __rest(_a, ["radius", "round", "x", "y", "crosshair"]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", __assign({}, other, { className: "mask-cursor", style: __assign(__assign({}, (other.style || {})), { height: "".concat(radius * 2, "px"), width: "".concat(radius * 2, "px"), 
            // Sort this out later after implementing
            // the calculations for radial search in fill()
            borderRadius: round ? "".concat(radius, "px") : undefined, transform: "translate(".concat(-radius, "px, ").concat(-radius, "px)"), left: pct2css(x), top: pct2css(y), position: "absolute", outline: "2px solid red", cursor: "none", overflow: "visible", pointerEvents: "none" }) }), crosshair ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("svg", { style: {
            position: "absolute",
            left: 0,
            top: 0,
            height: "100%",
            width: "100%",
            overflow: "visible",
            pointerEvents: "none",
        } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("line", { x1: "50%", x2: "50%", y1: "0%", y2: "100%", stroke: "red", strokeWidth: "2px" }),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("line", { y1: "50%", y2: "50%", x1: "0%", x2: "100%", stroke: "red", strokeWidth: "2px" }))) : null));
};

var Mask = function (_a) {
    var bitmap = _a.bitmap, activeColor = _a.activeColor, childProps = __rest(_a, ["bitmap", "activeColor"]);
    var canvas = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        if (bitmap && canvas.current) {
            var context = canvas.current.getContext("2d");
            if (!context) {
                throw "Failed to find canvas context.";
            }
            canvas.current.width = bitmap.dimensions.width;
            canvas.current.height = bitmap.dimensions.height;
            var pixels_1 = context.createImageData(bitmap.dimensions.width, bitmap.dimensions.height);
            Uint8ClampedArray.from(Array.from(bitmap.values)
                .map(function (v) {
                return valueToNodeStatus[v] === "matched"
                    ? activeColor
                    : [0, 0, 0, 0];
            })
                .flat()).forEach(function (v, i) { return (pixels_1.data[i] = v); });
            context.putImageData(pixels_1, 0, 0);
        }
    }, [bitmap, activeColor, canvas]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("canvas", __assign({}, childProps, { className: "region mask", style: __assign(__assign({}, (childProps.style || {})), { position: "absolute", width: "100%", height: "100%", top: 0 }), ref: canvas })));
};

var RegionList = function (_a) {
    var _b, _c;
    var config = _a.config, draft = _a.draft, callbacks = _a.callbacks;
    var cursor = config.regions.length > 0 ? "none" : undefined;
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
        draft.labels.masks.map(function (mask, index) {
            var _a;
            return draft.drawing.mode !== "masks" ||
                ((_a = draft.drawing.active) === null || _a === void 0 ? void 0 : _a.idx) !== index ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Mask, __assign({ activeColor: [0, 0, 255, 255], key: index, bitmap: mask.map, style: {
                    cursor: cursor,
                    pointerEvents: draft.drawing.mode === "masks" ? undefined : "none",
                } }, callbacks))) : null;
        }),
        draft.labels.polygons.map(function (polygon, index) {
            var _a;
            return draft.drawing.mode !== "polygons" ||
                ((_a = draft.drawing.active) === null || _a === void 0 ? void 0 : _a.idx) !== index ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Polygon, __assign({ polygon: polygon, style: {
                    cursor: cursor,
                    pointerEvents: draft.drawing.mode === "polygons" ? undefined : "none",
                }, key: index, color: "blue" }, callbacks, { onClick: function (event) {
                    return callbacks.onClick(event, polygon, index);
                } }))) : null;
        }),
        draft.labels.boxes.map(function (box, index) {
            var _a;
            return draft.drawing.mode !== "boxes" ||
                ((_a = draft.drawing.active) === null || _a === void 0 ? void 0 : _a.idx) !== index ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AlignedBox, __assign({ color: "blue", box: box, key: index, style: {
                    cursor: cursor,
                    pointerEvents: draft.drawing.mode === "boxes" ? undefined : "none",
                } }, callbacks, { onClick: function (event) {
                    return callbacks.onClick(event, box, index);
                } }))) : null;
        }),
        !draft.drawing.active ? null : draft.drawing.mode === "polygons" ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Polygon, __assign({ color: "red", polygon: draft.drawing.active.region }, callbacks, { candidate: draft.drawing.active.idx > -1 ? null : draft.cursor.coords, style: { cursor: cursor } }))) : draft.drawing.mode === "boxes" ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AlignedBox, __assign({ color: "red", box: draft.drawing.active.region, candidate: draft.drawing.active.idx > -1 ? null : draft.cursor.coords, style: { cursor: cursor } }, callbacks))) : draft.drawing.mode === "masks" ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Mask, __assign({ activeColor: [255, 0, 0, 255] }, callbacks, { bitmap: draft.drawing.active.region.map, style: { cursor: cursor } }))) : null,
        draft.cursor.coords && cursor !== undefined ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RegionCursor, __assign({}, callbacks, { radius: draft.drawing.mode === "masks" ? draft.cursor.radius : 5, x: draft.cursor.coords.x, y: draft.cursor.coords.y, crosshair: draft.drawing.mode === "masks"
                ? false
                : draft.drawing.mode === "boxes"
                    ? true
                    : isPolygonClosed(draft.cursor.coords, (_c = (_b = draft.drawing.active) === null || _b === void 0 ? void 0 : _b.region) === null || _c === void 0 ? void 0 : _c.points)
                        ? false
                        : true, round: draft.drawing.mode !== "masks" }))) : null));
};

var Metadata = function (_a) {
    var data = _a.data;
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.TableContainer, { tabIndex: 0, component: _mui_material__WEBPACK_IMPORTED_MODULE_1__.Paper, sx: { mb: 0, mt: 0 } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Table, { "aria-label": "metadata table" },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.TableBody, null, Object.entries(data).map(function (_a, idx) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.TableRow, { key: idx, sx: { "&:last-child td, &:last-child th": { border: 0 } } },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.TableCell, { align: "right", component: "th", scope: "row" },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("b", null, key)),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.TableCell, null, value)));
            })))));
};

// A simple progress bar inspired by https://github.com/abdennour/react-progressbar
var ProgressBar = function (props) {
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { display: "flex", alignItems: "center" } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { width: "100%", mr: 1 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.LinearProgress, { variant: "determinate", value: props.progress })),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { minWidth: 20, textAlign: "right" } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Typography, { variant: "body2", color: "text.secondary" }, "".concat(Math.round(props.progress), "%")))));
};

var LabelerLayout = function (_a) {
    var _b = _a.layout, layout = _b === void 0 ? "horizontal" : _b, control = _a.control, content = _a.content, metadata = _a.metadata, progress = _a.progress;
    var isLarge = useMediaLarge();
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
        progress !== undefined && progress >= 0 ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { mb: 1 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ProgressBar, { progress: progress }))) : null,
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: {
                display: "grid",
                gridTemplateColumns: content || metadata
                    ? layout === "horizontal" && isLarge
                        ? "315px 1fr"
                        : "1fr"
                    : "1fr",
                gridTemplateRows: "auto",
                gridTemplateAreas: content || metadata
                    ? layout === "horizontal" && isLarge
                        ? '"control-panel image-target"'
                        : '"image-target" "control-panel"'
                    : '"control-panel"',
                gridColumnGap: content || metadata ? 20 : 0,
                rowGap: content || metadata ? 20 : 0,
                position: "relative",
            } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: { position: "relative", gridArea: "control-panel" } },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClickTarget, null),
                control),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: { position: "relative", gridArea: "image-target" } },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClickTarget, null),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Stack, { rowGap: 1 },
                    content,
                    metadata ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { position: "relative", zIndex: 1 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Metadata, { data: metadata }))) : null)))));
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".minimap .mask-cursor {\n  display: none;\n}\n\n.minimap .box-text {\n  visibility: hidden;\n}\n\n.viewport .media img,\n.viewport .media video {\n  vertical-align: bottom;\n}\n\n.viewport .loading-placeholder .region {\n  visibility: hidden;\n}\n\n.media-viewer img,\n.media-viewer video {\n  width: 100%;\n  height: 100%;\n  max-width: none;\n  max-height: none;\n}\n\n.batch-image-list-item .batch-image-list-item-bar {\n  z-index: 1;\n  background: linear-gradient(\n    to bottom,\n    rgba(0, 0, 0, 0.7) 0%,\n    rgba(0, 0, 0, 0.3) 70%,\n    rgba(0, 0, 0, 0) 100%\n  );\n}\n\n.batch-image-list-item {\n  width: 100%;\n}\n\n.batch-image-list-item-bar .title-wrap {\n  padding: 8px;\n}\n\nlabel.label-panel-entry-option-label {\n  margin-bottom: 0;\n}\n\nlegend.label-panel-entry-label {\n  margin-bottom: 0;\n  border-bottom: none;\n}\n\n.batch-image-list-item img {\n  transition: opacity 1s;\n  z-index: 0;\n  opacity: 1;\n}\n\n.batch-image-list-item:active img,\n.batch-image-list-item.active {\n  transition: opacity 1s;\n  opacity: 0.25;\n}\n\n.demonstrator.animate .viewport .media .raw {\n  transition: width 0.5s, height 0.5s;\n}\n\n.demonstrator.animate .viewport .media {\n  transition: clip 0.5s, left 0.5s, top 0.5s;\n}\n";
styleInject(css_248z);

var DELAY$1 = 100;
var ImageLabeler = function (_a) {
    var target = _a.target, labels = _a.labels, options = _a.options, callbacks = _a.callbacks, metadata = _a.metadata, preload = _a.preload, config = _a.config, maxViewHeight = _a.maxViewHeight;
    var _b = useDraftLabelState(labels, [target]), draft = _b.draft, setDraft = _b.setDraft, resetDraft = _b.resetDraft;
    var refs = {
        viewer: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        source: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        canvas: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
    };
    var _c = useLoader(react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (event) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                var size = {
                    width: refs.source.current.naturalWidth,
                    height: refs.source.current.naturalHeight,
                };
                resolve({
                    size: size,
                    layout: size.height > size.width ? "horizontal" : "vertical",
                });
            }, DELAY$1);
        });
    }, [refs.source, target]), target), loader = _c.loader, disableControls = _c.disableControls, disableContents = _c.disableContents, visibleSource = _c.visibleSource, mediaState = _c.mediaState;
    var save = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {
        return (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave)
            ? callbacks.onSave(__assign(__assign({}, draft2labels(draft.labels)), { dimensions: mediaState === null || mediaState === void 0 ? void 0 : mediaState.size }))
            : undefined;
    }, [draft, mediaState, callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave]);
    var imageCallbacks = useMediaMouseCallbacks(draft, setDraft, refs, config.regions.length > 0, options === null || options === void 0 ? void 0 : options.maxCanvasSize);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelerLayout, { metadata: metadata, progress: options === null || options === void 0 ? void 0 : options.progress, layout: (mediaState === null || mediaState === void 0 ? void 0 : mediaState.layout) || "horizontal", control: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ControlMenu, { config: config, disabled: disableControls, direction: ((mediaState === null || mediaState === void 0 ? void 0 : mediaState.layout) || "horizontal") === "horizontal"
                ? "column"
                : "row", draft: draft, showNavigation: options === null || options === void 0 ? void 0 : options.showNavigation, setDraft: setDraft, callbacks: __assign(__assign({}, callbacks), { onSave: (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave) ? save : undefined, onReset: resetDraft }) }), content: target ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MediaViewer, { size: mediaState === null || mediaState === void 0 ? void 0 : mediaState.size, maxViewHeight: maxViewHeight, media: {
                        main: (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", __assign({}, imageCallbacks, { ref: refs.source, onLoad: loader, src: visibleSource, style: {
                                cursor: config.regions.length > 0 ? "none" : undefined,
                            } }))),
                        mini: react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", { src: visibleSource }),
                    }, loading: disableContents, onMouseLeave: function () {
                        return setDraft(__assign(__assign({}, draft), { cursor: __assign(__assign({}, draft.cursor), { coords: undefined }) }));
                    } },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RegionList, { config: config, draft: draft, callbacks: imageCallbacks }))),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement("canvas", { style: { display: "none" }, ref: refs.canvas }),
            !disableContents && preload ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ImagePreloader, { images: preload })) : null)) : null }));
};

var formatTime = function (t) {
    if (t === undefined || isNaN(t)) {
        return "00:00";
    }
    var minutes = Math.floor(t / 60)
        .toString()
        .padStart(2, "0");
    var seconds = Math.round(t % 60)
        .toString()
        .padStart(2, "0");
    return "".concat(minutes, ":").concat(seconds);
};
var Playbar = function (_a) {
    var timestamp = _a.timestamp, secondary = _a.secondary, duration = _a.duration, marks = _a.marks, setTimestamp = _a.setTimestamp, setSecondary = _a.setSecondary, secondaryThumbnail = _a.secondaryThumbnail;
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { width: "100%" }, className: "playbar" },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Stack, { direction: "row", alignItems: "center", spacing: 2 },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Typography, { fontSize: "small" },
                formatTime(timestamp),
                "/",
                formatTime(duration)),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: { width: "100%", display: "inherit", position: "relative" } },
                secondary !== undefined ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { style: {
                        position: "absolute",
                        maxWidth: 100,
                        maxHeight: 100,
                        left: pct2css(secondary / duration),
                        bottom: "60%",
                    } }, secondaryThumbnail)) : null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Slider, { size: "small", min: 0, step: 0.01, classes: { thumb: "slider-thumb" }, componentsProps: {
                        markLabel: {
                            onClick: function (event) {
                                return setTimestamp(marks[event.currentTarget.getAttribute("data-index")]);
                            },
                        },
                    }, max: duration || 10, valueLabelDisplay: "auto", marks: marks.map(function (value) {
                        return { value: value, label: value };
                    }), value: [timestamp].concat(secondary !== undefined ? [secondary] : []), onChange: function (event, value, activeThumb) {
                        if (event.altKey &&
                            (value.length == 1 ||
                                value[activeThumb] >= value[1 - activeThumb])) {
                            setSecondary(value[activeThumb]);
                        }
                        else if (!event.altKey) {
                            setTimestamp(value[activeThumb]);
                        }
                    } })))));
};

var DELAY = 100;
var VideoLabeler = function (_a) {
    var target = _a.target, config = _a.config, labels = _a.labels, metadata = _a.metadata, options = _a.options, callbacks = _a.callbacks, maxViewHeight = _a.maxViewHeight;
    var refs = {
        mini: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        main: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        secondaryThumbnail: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        viewer: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        canvas: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        playpause: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        fastforward: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        mute: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
    };
    var setFocus = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext).setFocus;
    var memoized = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function () { return labels || []; }, [labels]);
    var _b = usePlaybackState(refs, memoized), playbackState = _b.playbackState, setPlaybackState = _b.setPlaybackState, toggleMute = _b.toggleMute;
    var _c = useDraftLabelState(playbackState.labels, [playbackState.timestamp]), draft = _c.draft, setDraft = _c.setDraft, resetDraft = _c.resetDraft;
    useKeyboardEvent(function (event) {
        var target;
        switch (event.key) {
            case "Spacebar":
            case " ":
                target = !draft.dirty ? "playpause" : null;
                break;
            case "ArrowRight":
                target = event.altKey && !draft.dirty ? "fastforward" : null;
                break;
            case "m":
                target = event.altKey ? "mute" : null;
            default:
                return;
        }
        if (target && refs[target].current) {
            simulateClick(refs[target].current).then(setFocus);
            event.preventDefault();
            event.stopPropagation();
        }
    }, [refs]);
    var _d = useLoader(function (event) {
        return new Promise(function (resolve) {
            return setTimeout(function () {
                var size = {
                    width: refs.main.current.videoWidth,
                    height: refs.main.current.videoHeight,
                };
                resolve({
                    duration: refs.main.current.duration,
                    layout: size.height > size.width ? "horizontal" : "vertical",
                    size: size,
                });
            }, DELAY);
        });
    }, target), loader = _d.loader, visibleSource = _d.visibleSource, disableContents = _d.disableContents, disableControls = _d.disableControls, mediaState = _d.mediaState;
    var mediaCallbacks = useMediaMouseCallbacks(draft, setDraft, { source: refs.main, canvas: refs.canvas }, config.regions.length > 0, options === null || options === void 0 ? void 0 : options.maxCanvasSize);
    var buttons = [
        {
            icon: playbackState.paused ? _mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.PlayArrow : _mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.Pause,
            label: playbackState.paused ? "play (spacebar)" : "pause (spacebar)",
            className: "playpause",
            disabled: playbackState.paused && draft.dirty,
            ref: refs.playpause,
            callbacks: {
                onClick: function () { return setPlaybackState(playbackState.paused ? 1 : 0); },
            },
        },
        {
            icon: _mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.FastForward,
            label: "forward (alt\u2192)",
            className: "fastforward",
            ref: refs.fastforward,
            disabled: playbackState.paused && draft.dirty,
            callbacks: {
                onClick: function () { return setPlaybackState(playbackState.playbackRate + 1); },
            },
        },
        {
            icon: playbackState.muted ? _mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.VolumeMute : _mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.VolumeUp,
            label: "mute/unmute forward (alt+m)",
            className: "mute",
            ref: refs.mute,
            disabled: false,
            callbacks: {
                onClick: toggleMute,
            },
        },
    ];
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelerLayout, { metadata: metadata, layout: (mediaState === null || mediaState === void 0 ? void 0 : mediaState.layout) || "horizontal", progress: options === null || options === void 0 ? void 0 : options.progress, control: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ControlMenu, { config: config, disabled: disableControls || !playbackState.paused, direction: ((mediaState === null || mediaState === void 0 ? void 0 : mediaState.layout) || "horizontal") === "horizontal"
                ? "column"
                : "row", draft: draft, showNavigation: options === null || options === void 0 ? void 0 : options.showNavigation, setDraft: setDraft, callbacks: __assign(__assign({}, callbacks), { onSave: function () {
                    return (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave)
                        ? callbacks.onSave(insertOrAppendByTimestamp({
                            labels: draft2labels(draft.labels),
                            timestamp: playbackState.timestamp,
                            end: playbackState.end,
                        }, labels || []))
                        : undefined;
                }, onReset: resetDraft }) }), content: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MediaViewer, { maxViewHeight: maxViewHeight, size: mediaState === null || mediaState === void 0 ? void 0 : mediaState.size, loading: disableContents, onMouseLeave: function () {
                    return setDraft(__assign(__assign({}, draft), { cursor: __assign(__assign({}, draft.cursor), { coords: undefined }) }));
                }, media: {
                    main: (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("video", __assign({ disablePictureInPicture: true, onLoadedMetadata: loader }, mediaCallbacks, { ref: refs.main, src: visibleSource, style: {
                            cursor: config.regions.length > 0 ? "none" : undefined,
                        } }))),
                    mini: react__WEBPACK_IMPORTED_MODULE_0___default().createElement("video", { src: target, ref: refs.mini }),
                }, controls: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Stack, { direction: "row", alignItems: "center", spacing: 2 },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Stack, { direction: "row", alignItems: "center", spacing: 0 }, buttons.map(function (button) { return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.IconButton, __assign({}, button.callbacks, { className: button.className, disabled: button.disabled, ref: button.ref, key: button.label, "aria-label": button.label, title: button.label, size: "small" }),
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(button.icon, { fontSize: "small" }))); })),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Playbar, { marks: (labels || []).map(function (t) { return t.timestamp; }), timestamp: playbackState.timestamp, duration: mediaState === null || mediaState === void 0 ? void 0 : mediaState.duration, secondary: playbackState.end, secondaryThumbnail: react__WEBPACK_IMPORTED_MODULE_0___default().createElement("video", { src: target, ref: refs.secondaryThumbnail }), setSecondary: function (timestamp) {
                            return setPlaybackState(0, undefined, timestamp);
                        }, setTimestamp: function (timestamp) {
                            return draft.dirty ? undefined : setPlaybackState(0, timestamp);
                        } })) },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RegionList, { config: config, draft: draft, callbacks: mediaCallbacks })),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement("canvas", { style: { display: "none" }, ref: refs.canvas })) }));
};

var BatchImageLabeler = function (_a) {
    var target = _a.target, labels = _a.labels, options = _a.options, callbacks = _a.callbacks, setStates = _a.setStates, states = _a.states, config = _a.config, _b = _a.columns, columns = _b === void 0 ? 3 : _b;
    var isLarge = useMediaLarge();
    var toggle = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function (idx) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, setStates(states
                    .slice(0, idx)
                    .concat([__assign(__assign({}, states[idx]), { selected: !states[idx].selected })])
                    .concat(states.slice(idx + 1)))];
        });
    }); }, [setStates, states]);
    var setToast = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(GlobalLabelerContext).setToast;
    var _c = useDraftLabelState(labels, [target]), draft = _c.draft, setDraft = _c.setDraft, resetDraft = _c.resetDraft;
    var save = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {
        return (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave)
            ? callbacks.onSave(__assign({}, draft2labels(draft.labels)))
            : undefined;
    }, [draft, callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave]);
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        if (states &&
            states.some(function (s) {
                return ["boxes", "masks", "polygons"].some(function (k) { return s.labels && s.labels[k] && s.labels[k].length > 0; });
            })) {
            setToast("Warning: One of these items has region labels that will be overwritten upon saving.");
        }
    }, [states]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LabelerLayout, { layout: isLarge ? "horizontal" : "vertical", progress: options === null || options === void 0 ? void 0 : options.progress, control: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ControlMenu, { disabled: false, direction: "column", showNavigation: options === null || options === void 0 ? void 0 : options.showNavigation, config: { image: config.image, regions: undefined }, draft: draft, setDraft: setDraft, callbacks: __assign(__assign({}, callbacks), { onSave: (callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSave) ? save : undefined, onReset: resetDraft, onSelectAll: states.some(function (t) { return t.visible && !t.selected; })
                    ? function () {
                        return setStates(states.map(function (t) {
                            return __assign(__assign({}, t), { selected: t.visible });
                        }));
                    }
                    : undefined, onSelectNone: states.some(function (t) { return t.visible && t.selected; })
                    ? function () {
                        return setStates(states.map(function (t) {
                            return __assign(__assign({}, t), { selected: false });
                        }));
                    }
                    : undefined }) }), content: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ClickTarget, null),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ImageList, { cols: columns, sx: { mt: 0 }, variant: "masonry" }, states.map(function (t, tIdx) {
                var _a;
                return t.visible ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ImageListItem, { key: tIdx, className: "batch-image-list-item", "data-index": tIdx, onClick: function () { return toggle(tIdx); }, tabIndex: 0 },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ImageListItemBar, { className: "batch-image-list-item-bar", position: "top", classes: { titleWrap: "title-wrap" }, title: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { height: 25 } }, t.ignored ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { title: "ignored", flexDirection: "row-reverse", alignItems: "center", display: "flex" },
                            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.VisibilityOff, null))) : t.labeled ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { title: "labeled", flexDirection: "row-reverse", alignItems: "center", display: "flex" },
                            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.TurnedIn, null))) : null), actionIcon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.IconButton, { sx: { color: "white" }, "aria-label": "selected ".concat(tIdx), className: "toggle-button" }, t.selected ? react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.CheckCircle, null) : react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_icons_material__WEBPACK_IMPORTED_MODULE_2__.Circle, null)), actionPosition: "left" }),
                    target[tIdx] ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", { src: target[tIdx] })) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: { mb: 5 } })),
                    t.metadata ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Metadata, { data: Object.fromEntries(Object.entries(t.metadata || {}).concat(((_a = t.labels) === null || _a === void 0 ? void 0 : _a.image)
                            ? (config.image || [])
                                .map(function (c) {
                                return [
                                    c.displayName || c.name,
                                    t.labels.image[c.name]
                                        ? c.multiple
                                            ? t.labels.image[c.name].join(", ")
                                            : t.labels.image[c.name][0]
                                        : undefined,
                                ];
                            })
                                .filter(function (_a) {
                                var _b = __read(_a, 2); _b[0]; var v = _b[1];
                                return v !== undefined;
                            })
                            : [])) })) : null)) : null;
            }))) }));
};

var HiddenInput = react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) { return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { width: 0, height: 0, overflow: "hidden" } },
    react__WEBPACK_IMPORTED_MODULE_0___default().createElement("input", { ref: ref, className: "react-image-labeler-input-target" }))); });

var Labeler = function (_a) {
    var children = _a.children, other = __rest(_a, ["children"]);
    var refs = {
        hidden: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
        container: react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null),
    };
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(""), 2), toast = _b[0], setToast = _b[1];
    var setFocus = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function () {
        if (refs.hidden.current)
            refs.hidden.current.focus({ preventScroll: true });
    }, [refs.hidden]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(GlobalLabelerContext.Provider, { value: { container: refs.container, setToast: setToast, setFocus: setFocus } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { className: "react-image-labeler", ref: refs.container },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, __assign({}, other),
                children,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(HiddenInput, { ref: refs.hidden }),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Snackbar, { open: toast !== "", autoHideDuration: 3000, onClose: function () { return setToast(""); }, message: toast })))));
};

var animationMs = 250;
var getPosition = function (target, container, offset) {
    var trect = target.getBoundingClientRect();
    var crect = container.getBoundingClientRect();
    var initial = {
        x: trect.x + (offset ? offset.x : trect.width / 2),
        y: trect.y + (offset ? offset.y : trect.height / 2),
    };
    return {
        x: (initial.x - crect.x) / crect.width,
        y: (initial.y - crect.y) / crect.height,
    };
};
var Demonstrator = function (_a) {
    var children = _a.children, steps = _a.steps;
    var ref = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);
    var theme = (0,_mui_material__WEBPACK_IMPORTED_MODULE_1__.useTheme)();
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState(0), 2), idx = _b[0], setIdx = _b[1];
    var _c = __read(react__WEBPACK_IMPORTED_MODULE_0___default().useState({
        text: null,
        show: false,
        position: { x: 0.5, y: 0.5 },
    }), 2), message = _c[0], setMessage = _c[1];
    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {
        if (!ref) {
            return;
        }
        (function () { return __awaiter(void 0, void 0, void 0, function () {
            var step, nextIdx, target, offset, position;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        step = steps[idx];
                        nextIdx = idx + 1 < steps.length ? idx + 1 : 0;
                        target = ref.current.querySelector(step.target);
                        if (!target) {
                            console.error("Failed to find target", step.target);
                            setIdx(nextIdx);
                            return [2 /*return*/];
                        }
                        offset = step.offset
                            ? {
                                x: step.offset.x * target.clientWidth,
                                y: step.offset.y * target.clientHeight,
                            }
                            : undefined;
                        position = getPosition(target, ref.current, offset);
                        setMessage({
                            text: step.text,
                            show: true,
                            position: position,
                        });
                        return [4 /*yield*/, delay(1500)
                                .then(function () { return setMessage({ show: false, position: position, text: step.text }); })
                                .then(function () { return delay(animationMs); })
                                .then(function () { return setIdx(nextIdx); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); })();
    }, [ref, idx]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { ref: ref, style: { position: "relative" } },
        children,
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Box, { sx: {
                position: "absolute",
                left: pct2css(message.position.x),
                top: pct2css(message.position.y),
                width: 250,
                bgcolor: theme.palette.primary.main,
                color: theme.palette.primary.contrastText,
                border: "2px solid #000",
                boxShadow: 36,
                transition: "opacity ".concat(animationMs / 2, "ms"),
                p: 2,
                zIndex: 100,
                opacity: message.show ? 1.0 : 0.0,
            } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Typography, null, message.text))));
};


//# sourceMappingURL=index.esm.js.map


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_react-image-labeler_build_index_esm_js.cd8d5278865014af04db.js.map