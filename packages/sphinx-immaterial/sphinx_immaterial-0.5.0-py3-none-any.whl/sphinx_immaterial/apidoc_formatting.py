"""Modifies the formatting of API documentation."""

from typing import List, TYPE_CHECKING, cast

import docutils.nodes
import sphinx.addnodes
import sphinx.application
import sphinx.locale
import sphinx.writers.html5

_ = sphinx.locale._


if TYPE_CHECKING:
    HTMLTranslatorMixinBase = sphinx.writers.html5.HTML5Translator
else:
    HTMLTranslatorMixinBase = object


class HTMLTranslatorMixin(HTMLTranslatorMixinBase):  # pylint: disable=abstract-method
    """Mixin for HTMLTranslator that adds additional CSS classes."""

    def visit_desc(self, node: sphinx.addnodes.desc) -> None:
        # Object description node

        # These are converted to `<dl>` elements with the domain and objtype
        # as classes.

        # Augment the list of classes with `objdesc` to make it easier to
        # style these without resorting to hacks.
        node["classes"].append("objdesc")
        super().visit_desc(node)

    def visit_desc_type(self, node: sphinx.addnodes.desc_type) -> None:
        self.body.append(
            self.starttag(node, tagname="span", suffix="", CLASS="desctype")
        )

    def depart_desc_type(self, node: sphinx.addnodes.desc_type) -> None:
        self.body.append("</span>")

    def visit_desc_parameterlist(
        self, node: sphinx.addnodes.desc_parameterlist
    ) -> None:
        super().visit_desc_parameterlist(node)
        open_paren, _ = node.get("parens", ("(", ")"))
        self.body[-1] = self.body[-1].replace("(", open_paren)

    def depart_desc_parameterlist(
        self, node: sphinx.addnodes.desc_parameterlist
    ) -> None:
        super().depart_desc_parameterlist(node)
        _, close_paren = node.get("parens", ("(", ")"))
        self.body[-1] = self.body[-1].replace(")", close_paren)

    def visit_desc_parameter(self, node: sphinx.addnodes.desc_parameter) -> None:
        self.body.append('<span class="sig-param-decl">')
        super().visit_desc_parameter(node)

    def depart_desc_parameter(self, node: sphinx.addnodes.desc_parameter) -> None:
        super().depart_desc_parameter(node)
        self.body.append("</span>")

    def depart_field_name(self, node: docutils.nodes.Element) -> None:
        self.add_permalink_ref(node, _("Permalink to this headline"))
        super().depart_field_name(node)

    def depart_term(self, node: docutils.nodes.Element) -> None:
        if "ids" in node:
            self.add_permalink_ref(node, _("Permalink to this definition"))
        super().depart_term(node)

    def visit_caption(self, node: docutils.nodes.Element) -> None:
        attributes = {"class": "caption-text"}
        if isinstance(node.parent, docutils.nodes.container) and node.parent.get(
            "literal_block"
        ):
            # add highlight class to caption's div container.
            # This is needed to trigger mkdocs-material CSS rule `.highlight .filename`
            self.body.append('<div class="code-block-caption highlight">')
            # append a CSS class to trigger mkdocs-material theme's caption CSS style
            attributes["class"] += " filename"
        else:
            super().visit_caption(node)
        self.add_fignumber(node.parent)
        self.body.append(self.starttag(node, "span", **attributes))

    def depart_caption(self, node: docutils.nodes.Element) -> None:
        if not isinstance(
            node.parent, docutils.nodes.container
        ) and not node.parent.get("literal_block"):
            # only append ending tag if parent is not a literal-block.
            # Because all elements in the caption should be within a span element
            self.body.append("</span>")

        # append permalink if available
        if isinstance(node.parent, docutils.nodes.container) and node.parent.get(
            "literal_block"
        ):
            self.add_permalink_ref(node.parent, _("Permalink to this code"))
            self.body.append("</span>")  # done; add closing tag
        elif isinstance(node.parent, docutils.nodes.figure):
            self.add_permalink_ref(node.parent, _("Permalink to this image"))
        elif node.parent.get("toctree"):
            self.add_permalink_ref(node.parent.parent, _("Permalink to this toctree"))

        if isinstance(node.parent, docutils.nodes.container) and node.parent.get(
            "literal_block"
        ):
            self.body.append("</div>\n")
        else:
            super().depart_caption(node)

    # `desc_inline` nodes are generated by the `cpp:expr` role.
    #
    # Wrap it in a `<code>` element with the "highlight" class to ensure it
    # displays properly as an inline code literal.
    def visit_desc_inline(self, node: sphinx.addnodes.desc_inline) -> None:
        self.body.append(
            self.starttag(node, tagname="code", suffix="", CLASS="highlight")
        )

    def depart_desc_inline(self, node: sphinx.addnodes.desc_inline) -> None:
        self.body.append("</code>")


def _wrap_signature(node: sphinx.addnodes.desc_signature, limit: int):
    """Wraps long function signatures.

    Adds the `sig-wrap` class which causes each parameter to be displayed on a
    separate line.
    """
    node_text = node.astext()
    if len(node_text) > limit:
        node["classes"].append("sig-wrap")


def _wrap_signatures(
    app: sphinx.application.Sphinx,
    domain: str,
    objtype: str,
    content: docutils.nodes.Element,
) -> None:
    enabled = app.config.html_wrap_signatures_with_css
    if enabled is True or enabled is None:
        pass
    elif enabled is False:
        return
    elif domain not in enabled:
        return
    signatures = content.parent[:-1]
    for signature in signatures:
        _wrap_signature(
            signature, app.config.html_wrap_signatures_with_css_column_limit
        )


def _monkey_patch_object_description_to_include_fields_in_toc():
    orig_run = sphinx.directives.ObjectDescription.run

    def run(self: sphinx.directives.ObjectDescription) -> List[docutils.nodes.Node]:
        nodes = orig_run(self)

        if not self.env.config.include_object_description_fields_in_toc:
            return nodes

        obj_desc = nodes[-1]

        obj_id = None
        for sig in obj_desc[:-1]:
            ids = sig["ids"]
            if ids and ids[0]:
                obj_id = ids[0]
                break

        obj_content = obj_desc[-1]
        for child in obj_content:
            if not isinstance(child, docutils.nodes.field_list):
                continue
            for field in child:
                field_name = cast(docutils.nodes.field_name, field[0])
                if field_name["ids"]:
                    continue
                field_id = docutils.nodes.make_id(field_name.astext())
                if obj_id:
                    field_id = f"{obj_id}-{field_id}"
                field_name["ids"].append(field_id)

        return nodes

    sphinx.directives.ObjectDescription.run = run


def setup(app: sphinx.application.Sphinx):
    """Registers the monkey patches.

    Does not register HTMLTranslatorMixin, the caller must do that.
    """
    # Add "highlight" class in order for pygments syntax highlighting CSS rules
    # to apply.
    sphinx.addnodes.desc_signature.classes.append("highlight")

    app.add_config_value("html_wrap_signatures_with_css", default=None, rebuild="env")
    app.add_config_value(
        "html_wrap_signatures_with_css_column_limit", default=68, rebuild="env"
    )

    app.add_config_value(
        "include_object_description_fields_in_toc", default=True, rebuild="env"
    )

    app.connect("object-description-transform", _wrap_signatures)
    _monkey_patch_object_description_to_include_fields_in_toc()

    return {
        "parallel_read_safe": True,
        "parallel_write_safe": True,
    }
