{"version":3,"file":"static/js/545.4c9cf810.chunk.js","mappings":"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","sources":["../../core/src/asset-graph/Utils.tsx","../../core/src/asset-graph/layout.ts"],"sourcesContent":["import {gql} from '@apollo/client';\nimport {pathVerticalDiagonal} from '@vx/shape';\n\nimport {AssetNodeDefinitionFragment} from '../assets/types/AssetNodeDefinitionFragment';\n\nimport {AssetGraphLiveQuery_assetNodes_assetMaterializations} from './types/AssetGraphLiveQuery';\nimport {\n  AssetGraphQuery_assetNodes,\n  AssetGraphQuery_assetNodes_assetKey,\n} from './types/AssetGraphQuery';\nimport {AssetNodeLiveFragment} from './types/AssetNodeLiveFragment';\nimport {\n  RepositoryLiveFragment,\n  RepositoryLiveFragment_latestRunByStep_run,\n} from './types/RepositoryLiveFragment';\n\ntype AssetNode = AssetGraphQuery_assetNodes;\ntype AssetKey = AssetGraphQuery_assetNodes_assetKey;\n\nexport const __ASSET_GROUP_PREFIX = '__ASSET_GROUP';\n\nexport function isAssetGroup(jobName: string) {\n  return jobName.startsWith(__ASSET_GROUP_PREFIX);\n}\n\n// IMPORTANT: We use this, rather than AssetNode.id throughout this file because\n// the GraphQL interface exposes dependencyKeys, not dependencyIds. We also need\n// ways to \"build\" GraphId's locally, they can't always be server-provided.\n//\n// This value is NOT the same as AssetNode.id values provided by the server,\n// because JSON.stringify's whitespace behavior is different than Python's.\n//\nexport type GraphId = string;\nexport const toGraphId = (key: AssetKey): GraphId => JSON.stringify(key.path);\n\nexport interface GraphNode {\n  id: GraphId;\n  assetKey: AssetKey;\n  definition: AssetNode;\n}\n\nexport interface GraphData {\n  nodes: {[assetId: GraphId]: GraphNode};\n  downstream: {[assetId: GraphId]: {[childAssetId: GraphId]: boolean}};\n  upstream: {[assetId: GraphId]: {[parentAssetId: GraphId]: boolean}};\n}\nexport const isSourceAsset = (node: {jobNames: string[]; opName: string | null}) => {\n  return node.jobNames.length === 0 && !node.opName;\n};\n\nexport const buildGraphData = (assetNodes: AssetNode[]) => {\n  const data: GraphData = {\n    nodes: {},\n    downstream: {},\n    upstream: {},\n  };\n\n  const addEdge = (upstreamGraphId: string, downstreamGraphId: string) => {\n    data.downstream[upstreamGraphId] = {\n      ...(data.downstream[upstreamGraphId] || {}),\n      [downstreamGraphId]: true,\n    };\n    data.upstream[downstreamGraphId] = {\n      ...(data.upstream[downstreamGraphId] || {}),\n      [upstreamGraphId]: true,\n    };\n  };\n\n  assetNodes.forEach((definition: AssetNode) => {\n    const id = toGraphId(definition.assetKey);\n    definition.dependencyKeys.forEach((key) => {\n      addEdge(toGraphId(key), id);\n    });\n    definition.dependedByKeys.forEach((key) => {\n      addEdge(id, toGraphId(key));\n    });\n\n    data.nodes[id] = {\n      id,\n      assetKey: definition.assetKey,\n      definition,\n    };\n  });\n\n  return data;\n};\n\nexport const buildGraphDataFromSingleNode = (assetNode: AssetNodeDefinitionFragment) => {\n  const id = toGraphId(assetNode.assetKey);\n  const graphData: GraphData = {\n    downstream: {\n      [id]: {},\n    },\n    nodes: {\n      [id]: {\n        id,\n        assetKey: assetNode.assetKey,\n        definition: {...assetNode, dependencyKeys: [], dependedByKeys: []},\n      },\n    },\n    upstream: {\n      [id]: {},\n    },\n  };\n\n  for (const {asset} of assetNode.dependencies) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[id][depId] = true;\n    graphData.downstream[depId] = {...graphData.downstream[depId], [id]: true};\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  for (const {asset} of assetNode.dependedBy) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[depId] = {...graphData.upstream[depId], [id]: true};\n    graphData.downstream[id][depId] = true;\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  return graphData;\n};\n\nexport const graphHasCycles = (graphData: GraphData) => {\n  const nodes = new Set(Object.keys(graphData.nodes));\n  const search = (stack: string[], node: string): boolean => {\n    if (stack.indexOf(node) !== -1) {\n      return true;\n    }\n    if (nodes.delete(node) === true) {\n      const nextStack = stack.concat(node);\n      return Object.keys(graphData.downstream[node] || {}).some((nextNode) =>\n        search(nextStack, nextNode),\n      );\n    }\n    return false;\n  };\n  let hasCycles = false;\n  while (nodes.size !== 0) {\n    hasCycles = hasCycles || search([], nodes.values().next().value);\n  }\n  return hasCycles;\n};\n\nexport const buildSVGPath = pathVerticalDiagonal({\n  source: (s: any) => s.source,\n  target: (s: any) => s.target,\n  x: (s: any) => s.x,\n  y: (s: any) => s.y,\n});\n\nexport type Status = 'good' | 'old' | 'none' | 'unknown';\n\nexport interface LiveDataForNode {\n  computeStatus: Status;\n  unstartedRunIds: string[]; // run in progress and step not started\n  inProgressRunIds: string[]; // run in progress and step in progress\n  runWhichFailedToMaterialize: RepositoryLiveFragment_latestRunByStep_run | null;\n  lastMaterialization: AssetGraphLiveQuery_assetNodes_assetMaterializations | null;\n  lastChanged: number;\n}\nexport interface LiveData {\n  [assetId: GraphId]: LiveDataForNode;\n}\n\nexport const buildLiveData = (\n  graph: GraphData,\n  nodes: AssetNodeLiveFragment[],\n  repos: RepositoryLiveFragment[],\n) => {\n  const data: LiveData = {};\n\n  for (const liveNode of nodes) {\n    const graphId = toGraphId(liveNode.assetKey);\n    const graphNode = graph.nodes[graphId];\n    if (!graphNode) {\n      console.warn(`buildLiveData could not find the graph node matching ${graphId}`);\n      continue;\n    }\n    const lastMaterialization = liveNode.assetMaterializations[0] || null;\n    const lastChanged = Number(lastMaterialization?.timestamp || 0) / 1000;\n    const isPartitioned = graphNode.definition.partitionDefinition;\n    const repo = repos.find((r) => r.id === liveNode.repository.id);\n\n    const runs = repo?.inProgressRunsByStep.find((r) => r.stepKey === liveNode.opName);\n    const info = repo?.latestRunByStep.find((r) => r.stepKey === liveNode.opName);\n\n    const latestRunForStepKey = info?.__typename === 'LatestRun' ? info.run : null;\n\n    const runWhichFailedToMaterialize =\n      (latestRunForStepKey?.status === 'FAILURE' &&\n        (!lastMaterialization || lastMaterialization.runId !== latestRunForStepKey?.id) &&\n        latestRunForStepKey) ||\n      null;\n\n    data[graphId] = {\n      lastChanged,\n      lastMaterialization,\n      inProgressRunIds: runs?.inProgressRuns.map((r) => r.id) || [],\n      unstartedRunIds: runs?.unstartedRuns.map((r) => r.id) || [],\n      runWhichFailedToMaterialize,\n      computeStatus: isSourceAsset(graphNode.definition)\n        ? 'good' // foreign nodes are always considered up-to-date\n        : isPartitioned\n        ? // partitioned nodes are not supported, need to compare materializations\n          // of the same partition key and the API does not make fetching this easy\n          'none'\n        : lastMaterialization\n        ? 'unknown' // resolve to 'good' or 'old' by looking upstream\n        : 'none',\n    };\n  }\n\n  for (const liveNodeId of Object.keys(data)) {\n    data[liveNodeId].computeStatus = findComputeStatusForId(data, graph.upstream, liveNodeId);\n  }\n\n  return data;\n};\n\nfunction findComputeStatusForId(\n  data: LiveData,\n  upstream: {[assetId: string]: {[upstreamAssetId: string]: boolean}},\n  assetId: string,\n): Status {\n  if (!data[assetId]) {\n    // Currently compute status assumes foreign nodes are up to date\n    // and only shows \"upstream changed\" for upstreams in the same job\n    return 'good';\n  }\n  const ts = data[assetId].lastChanged;\n  const upstreamIds = Object.keys(upstream[assetId] || {});\n  if (data[assetId].computeStatus !== 'unknown') {\n    return data[assetId].computeStatus;\n  }\n\n  return upstreamIds.some((uid) => data[uid]?.lastChanged > ts)\n    ? 'old'\n    : upstreamIds.some((uid) => findComputeStatusForId(data, upstream, uid) !== 'good')\n    ? 'old'\n    : 'good';\n}\n\nexport function tokenForAssetKey(key: {path: string[]}) {\n  return key.path.join('>');\n}\n\nexport function displayNameForAssetKey(key: {path: string[]}) {\n  return key.path.join(' > ');\n}\n\nexport const IN_PROGRESS_RUNS_FRAGMENT = gql`\n  fragment InProgressRunsFragment on InProgressRunsByStep {\n    stepKey\n    unstartedRuns {\n      id\n    }\n    inProgressRuns {\n      id\n    }\n  }\n`;\n\nexport const LAST_RUNS_WARNINGS_FRAGMENT = gql`\n  fragment LastRunsWarningsFragment on LatestRun {\n    stepKey\n    run {\n      id\n      status\n    }\n  }\n`;\n\nexport const REPOSITORY_LIVE_FRAGMENT = gql`\n  fragment RepositoryLiveFragment on Repository {\n    id\n    name\n    location {\n      id\n      name\n    }\n    inProgressRunsByStep {\n      ...InProgressRunsFragment\n    }\n    latestRunByStep {\n      __typename\n      ...LastRunsWarningsFragment\n    }\n  }\n  ${IN_PROGRESS_RUNS_FRAGMENT}\n  ${LAST_RUNS_WARNINGS_FRAGMENT}\n`;\n","import * as dagre from 'dagre';\n\nimport {IBounds, IPoint} from '../graph/common';\n\nimport {GraphData, GraphNode, GraphId, displayNameForAssetKey} from './Utils';\n\nexport interface AssetLayout {\n  id: GraphId;\n\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n}\n\nexport type AssetLayoutEdge = {\n  from: IPoint;\n  to: IPoint;\n  dashed: boolean;\n};\n\nexport type AssetGraphLayout = {\n  width: number;\n  height: number;\n  edges: AssetLayoutEdge[];\n  nodes: {[id: string]: AssetLayout};\n};\n\nconst opts: {margin: number; mini: boolean} = {\n  margin: 100,\n  mini: false,\n};\n\nexport const layoutAssetGraph = (graphData: GraphData): AssetGraphLayout => {\n  const g = new dagre.graphlib.Graph();\n\n  g.setGraph({\n    rankdir: 'TB',\n    marginx: opts.margin,\n    marginy: opts.margin,\n    nodesep: opts.mini ? 20 : 50,\n    edgesep: opts.mini ? 10 : 10,\n    ranksep: opts.mini ? 20 : 50,\n  });\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const shouldRender = (node?: GraphNode) => node && node.definition.opName;\n\n  Object.values(graphData.nodes)\n    .filter(shouldRender)\n    .forEach((node) => {\n      const {width, height} = getAssetNodeDimensions(node.definition);\n      g.setNode(node.id, {width: opts.mini ? 230 : width, height});\n    });\n\n  const foreignNodes = {};\n  Object.keys(graphData.downstream).forEach((upstreamId) => {\n    const downstreamIds = Object.keys(graphData.downstream[upstreamId]);\n    downstreamIds.forEach((downstreamId) => {\n      if (\n        !shouldRender(graphData.nodes[downstreamId]) &&\n        !shouldRender(graphData.nodes[upstreamId])\n      ) {\n        return;\n      }\n      g.setEdge({v: upstreamId, w: downstreamId}, {weight: 1});\n\n      if (!shouldRender(graphData.nodes[downstreamId])) {\n        foreignNodes[downstreamId] = true;\n      } else if (!shouldRender(graphData.nodes[upstreamId])) {\n        foreignNodes[upstreamId] = true;\n      }\n    });\n  });\n\n  Object.keys(foreignNodes).forEach((id) => {\n    g.setNode(id, getForeignNodeDimensions(id));\n  });\n\n  dagre.layout(g);\n\n  const dagreNodesById: {[id: string]: dagre.Node} = {};\n  g.nodes().forEach((id) => {\n    const node = g.node(id);\n    if (!node) {\n      return;\n    }\n    dagreNodesById[id] = node;\n  });\n\n  let maxWidth = 0;\n  let maxHeight = 0;\n  const nodes: {[id: string]: AssetLayout} = {};\n  Object.keys(dagreNodesById).forEach((id) => {\n    const dagreNode = dagreNodesById[id];\n    nodes[id] = {\n      id,\n      bounds: {\n        x: dagreNode.x - dagreNode.width / 2,\n        y: dagreNode.y - dagreNode.height / 2,\n        width: dagreNode.width,\n        height: dagreNode.height,\n      },\n    };\n    maxWidth = Math.max(maxWidth, dagreNode.x + dagreNode.width / 2);\n    maxHeight = Math.max(maxHeight, dagreNode.y + dagreNode.height / 2);\n  });\n\n  const edges: AssetLayoutEdge[] = [];\n  g.edges().forEach((e) => {\n    const points = g.edge(e).points;\n    edges.push({\n      from: points[0],\n      to: points[points.length - 1],\n      dashed: false,\n    });\n  });\n\n  return {\n    nodes,\n    edges,\n    width: maxWidth + opts.margin,\n    height: maxHeight + opts.margin,\n  };\n};\n\nexport const getForeignNodeDimensions = (id: string) => {\n  const path = JSON.parse(id);\n  return {width: displayNameForAssetKey({path}).length * 8 + 30, height: 30};\n};\n\nexport const ASSET_NODE_ANNOTATIONS_MAX_WIDTH = 65;\nexport const ASSET_NODE_NAME_MAX_LENGTH = 50;\nconst DISPLAY_NAME_PX_PER_CHAR = 8.0;\n\nexport const getAssetNodeDimensions = (def: {\n  assetKey: {path: string[]};\n  opName: string | null;\n  description?: string | null;\n}) => {\n  let height = 75;\n  if (def.description) {\n    height += 25;\n  }\n  const displayName = displayNameForAssetKey(def.assetKey);\n  if (def.opName && displayName !== def.opName) {\n    height += 25;\n  }\n  return {\n    width:\n      Math.max(\n        200,\n        Math.min(ASSET_NODE_NAME_MAX_LENGTH, displayName.length) * DISPLAY_NAME_PX_PER_CHAR,\n      ) + ASSET_NODE_ANNOTATIONS_MAX_WIDTH,\n    height,\n  };\n};\n"],"names":["pathVerticalDiagonal","source","s","target","x","y","displayNameForAssetKey","key","path","join","IN_PROGRESS_RUNS_FRAGMENT","gql","LAST_RUNS_WARNINGS_FRAGMENT","opts","layoutAssetGraph","graphData","g","dagre","setGraph","rankdir","marginx","marginy","nodesep","edgesep","ranksep","setDefaultEdgeLabel","shouldRender","node","definition","opName","Object","values","nodes","filter","forEach","getAssetNodeDimensions","width","height","setNode","id","foreignNodes","keys","downstream","upstreamId","downstreamId","setEdge","v","w","weight","getForeignNodeDimensions","dagreNodesById","maxWidth","maxHeight","dagreNode","bounds","Math","max","edges","e","points","edge","push","from","to","length","dashed","JSON","parse","ASSET_NODE_ANNOTATIONS_MAX_WIDTH","ASSET_NODE_NAME_MAX_LENGTH","def","description","displayName","assetKey","min"],"sourceRoot":""}